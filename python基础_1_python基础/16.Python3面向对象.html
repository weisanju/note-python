<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python3面向对象</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title">python基础</li><li class="chapter-item expanded "><a href="../python基础_1_python基础/index.html"><strong aria-hidden="true">1.</strong> python基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python基础_1_python基础/1.python3基础语法.html"><strong aria-hidden="true">1.1.</strong> python3基础语法</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/2.基本数据类型.html"><strong aria-hidden="true">1.2.</strong> 基本数据类型</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/3.Python3数据类型转换.html"><strong aria-hidden="true">1.3.</strong> Python3数据类型转换</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/4.Python推导式.html"><strong aria-hidden="true">1.4.</strong> Python推导式</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/5.Python3运算符.html"><strong aria-hidden="true">1.5.</strong> Python3运算符</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/6.Python3字符串.html"><strong aria-hidden="true">1.6.</strong> Python3字符串</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/7.python3列表.html"><strong aria-hidden="true">1.7.</strong> python3列表</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/8.元祖.html"><strong aria-hidden="true">1.8.</strong> 元祖</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/9.Python3字典.html"><strong aria-hidden="true">1.9.</strong> Python3字典</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/10.Python3集合.html"><strong aria-hidden="true">1.10.</strong> Python3集合</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/11.Number类型.html"><strong aria-hidden="true">1.11.</strong> Number类型</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/12.python3流程控制.html"><strong aria-hidden="true">1.12.</strong> python3流程控制</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/13.Python3迭代器与生成器.html"><strong aria-hidden="true">1.13.</strong> Python3迭代器与生成器</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/14.函数.html"><strong aria-hidden="true">1.14.</strong> 函数</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/15.Python3JSON数据解析.html"><strong aria-hidden="true">1.15.</strong> Python3JSON数据解析</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/16.Python3面向对象.html" class="active"><strong aria-hidden="true">1.16.</strong> Python3面向对象</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/17.模块与包.html"><strong aria-hidden="true">1.17.</strong> 模块与包</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/With关键字.html"><strong aria-hidden="true">1.18.</strong> With关键字</a></li><li class="chapter-item expanded "><a href="../python基础_1_python基础/杂项.html"><strong aria-hidden="true">1.19.</strong> 杂项</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">python三方库</li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> fabric</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python三方库_2_fabric/fabric/index.html"><strong aria-hidden="true">2.1.</strong> fabric</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python三方库_2_fabric/fabric/Configuration.html"><strong aria-hidden="true">2.1.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../python三方库_2_fabric/fabric/README_1.x.html"><strong aria-hidden="true">2.1.2.</strong> README_1.x</a></li></ol></li><li class="chapter-item expanded "><a href="../python三方库_2_fabric/invoke/index.html"><strong aria-hidden="true">2.2.</strong> invoke</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python三方库_2_fabric/invoke/1.DefiningAndRunningTask.html"><strong aria-hidden="true">2.2.1.</strong> DefiningAndRunningTask</a></li><li class="chapter-item expanded "><a href="../python三方库_2_fabric/invoke/2.InvokeCoreUsage.html"><strong aria-hidden="true">2.2.2.</strong> InvokeCoreUsage</a></li><li class="chapter-item expanded "><a href="../python三方库_2_fabric/invoke/3.Configuration.html"><strong aria-hidden="true">2.2.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../python三方库_2_fabric/invoke/4.loadingCollections.html"><strong aria-hidden="true">2.2.4.</strong> loadingCollections</a></li><li class="chapter-item expanded "><a href="../python三方库_2_fabric/invoke/5.UsingInvokeAslibrary.html"><strong aria-hidden="true">2.2.5.</strong> UsingInvokeAslibrary</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="python3-面向对象"><a class="header" href="#python3-面向对象">Python3 面向对象</a></h1>
<p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</p>
<p>接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<hr />
<h2 id="面向对象技术简介"><a class="header" href="#面向对象技术简介">面向对象技术简介</a></h2>
<ul>
<li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li>**方法：**类中定义的函数。</li>
<li>**类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li>**数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li>**局部变量：**定义在方法中的变量，只作用于当前实例的类。</li>
<li>**实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li>
<li>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</li>
<li>**实例化：**创建一个类的实例，类的具体对象。</li>
<li>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p>
<p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>对象可以包含任意数量和类型的数据。</p>
<h2 id="类定义"><a class="header" href="#类定义">类定义</a></h2>
<p>语法格式如下：</p>
<pre><code>class ClassName:    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;
</code></pre>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<h2 id="创建类"><a class="header" href="#创建类">创建类</a></h2>
<p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p>
<pre><code class="language-python">class ClassName:
   '类的帮助信息'   #类文档字符串
   class_suite  #类体
  
  
 // 类的帮助信息可以通过ClassName.__doc__查看。
 // class_suite 由类成员，方法，数据属性组成。
</code></pre>
<h2 id="python内置类属性"><a class="header" href="#python内置类属性">Python内置类属性</a></h2>
<ul>
<li><code>__dict__ </code>: 类的属性（包含一个字典，由类的数据属性组成）</li>
<li><code>__doc__</code> :类的文档字符串</li>
<li><code>__name__</code>: 类名</li>
<li><code>__module__</code>: 类定义所在的模块（类的全名是'<strong>main</strong>.className'，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）</li>
<li><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li>
</ul>
<h2 id="类对象"><a class="header" href="#类对象">类对象</a></h2>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class MyClass:    
  &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;    
  i = 12345    
  def f(self): return 'hello world'  
# 实例化类 
x = MyClass()  
# 访问类的属性和方法 
print(&quot;MyClass 类的属性 i 为：&quot;, x.i) 
print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())
</code></pre>
<p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<pre><code>MyClass 类的属性 i 为： 12345
MyClass 类的方法 f 输出为： hello world
</code></pre>
<hr />
<p>类有一个名为 <strong>init</strong>() 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，像下面这样：</p>
<pre><code>def __init__(self):    self.data = []
</code></pre>
<p>类定义了 <strong>init</strong>() 方法，类的实例化操作会自动调用 <strong>init</strong>() 方法。如下实例化类 MyClass，对应的 <strong>init</strong>() 方法就会被调用:</p>
<pre><code>x = MyClass()
</code></pre>
<p>当然， <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。例如:</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class Complex:    
	def __init__(self, realpart, imagpart):        
		self.r = realpart        
		self.i = imagpart 

x = Complex(3.0, -4.5) 
print(x.r, x.i)   
# 输出结果：3.0 -4.5
</code></pre>
<h3 id="self代表类的实例而非类"><a class="header" href="#self代表类的实例而非类">self代表类的实例，而非类</a></h3>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p>
<pre><code class="language-python">class Test:    
	def prt(self):        
		print(self)        
		print(self.__class__)  
		
t = Test() 
t.prt()
</code></pre>
<p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre>
<p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p>
<p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p>
<pre><code class="language-python">class Test:    
	def prt(runoob):        
	print(runoob)        
	print(runoob.__class__)  

t = Test() 
t.prt()
</code></pre>
<p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre>
<hr />
<h2 id="类的方法"><a class="header" href="#类的方法">类的方法</a></h2>
<p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
#类定义 
class people:    
#定义基本属性   
	name = ''    
  age = 0    
#定义私有属性,私有属性在类外部无法直接进行访问    
__weight = 0    
#定义构造方法    
def __init__(self,n,a,w):        
  self.name = n        
  self.age = a        
  self.__weight = w    
  
def speak(self):        
  print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))  
 # 实例化类 
p = people('runoob',10,30) 
p.speak()
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>runoob 说: 我 10 岁。
</code></pre>
<hr />
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p>
<pre><code>class DerivedClassName(BaseClassName):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;
</code></pre>
<p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p>
<p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<pre><code>class DerivedClassName(modname.BaseClassName):
</code></pre>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
#类定义 
class people:    
#定义基本属性    
	name = ''    
	age = 0    
#定义私有属性,私有属性在类外部无法直接进行访问    
	__weight = 0    
#定义构造方法    
def __init__(self,n,a,w):        
	self.name = n        
  self.age = a        
  self.__weight = w    
def speak(self):        
  print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))  
#单继承示例 
class student(people):    
  grade = ''    
  def __init__(self,n,a,w,g):        
#调用父类的构函        
	people.__init__(self,n,a,w)        
  self.grade = g    
#覆写父类的方法    
	def speak(self):        
  print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))    
  
s = student('ken',10,60,3) 
s.speak()
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>ken 说: 我 10 岁了，我在读 3 年级
</code></pre>
<hr />
<h2 id="多继承"><a class="header" href="#多继承">多继承</a></h2>
<p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<pre><code>class DerivedClassName(Base1, Base2, Base3):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;
</code></pre>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，<strong>从左到右查找父类中是否包含方法。</strong></p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
#类定义 
class people:    
#定义基本属性    
name = ''    age = 0   
#定义私有属性,私有属性在类外部无法直接进行访问   
__weight = 0    
#定义构造方法    
def __init__(self,n,a,w):        
  self.name = n        
  self.age = a        
  self.__weight = w    
def speak(self):        
  print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))  
#单继承示例 
class student(people):    
  grade = ''    
  def __init__(self,n,a,w,g):        
    #调用父类的构函        
    people.__init__(self,n,a,w)        
    self.grade = g    
#覆写父类的方法    
	def speak(self):        
    print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))  
#另一个类，多重继承之前的准备 
class speaker():    
  topic = ''    
  name = ''    
  def __init__(self,n,t):        
    self.name = n        
    self.topic = t    
def speak(self):        
  print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))  
#多重继承 
class sample(speaker,student):    
	a =''    def __init__(self,n,a,w,g,t):        
	student.__init__(self,n,a,w,g)        
  speaker.__init__(self,n,t)  
  
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;) 
test.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<hr />
<h2 id="方法重写"><a class="header" href="#方法重写">方法重写</a></h2>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class Parent:        
  # 定义父类   
  def myMethod(self):      
    print ('调用父类方法')  
class Child(Parent): 
  # 定义子类   
  def myMethod(self):      
    print ('调用子类方法')  
    
c = Child()          
# 子类实例 
c.myMethod()         
# 子类调用重写方法 
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
</code></pre>
<p><a href="https://www.runoob.com/python/python-func-super.html">super() 函数</a>是用于调用父类(超类)的一个方法。</p>
<p>执行以上程序输出结果为：</p>
<pre><code>调用子类方法
调用父类方法
</code></pre>
<p><strong>更多文档：</strong></p>
<p><a href="https://www.runoob.com/w3cnote/python-extends-init.html">Python 子类继承父类构造函数说明</a></p>
<hr />
<h2 id="类属性与方法"><a class="header" href="#类属性与方法">类属性与方法</a></h2>
<h3 id="类的私有属性"><a class="header" href="#类的私有属性">类的私有属性</a></h3>
<p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p>
<h3 id="类的方法-1"><a class="header" href="#类的方法-1">类的方法</a></h3>
<p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p>
<p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p>
<h3 id="类的私有方法"><a class="header" href="#类的私有方法">类的私有方法</a></h3>
<p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p>
<h3 id="实例"><a class="header" href="#实例">实例</a></h3>
<p>类的私有属性实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3 
class JustCounter:    
  __secretCount = 0  
# 私有变量    
	publicCount = 0    
# 公开变量     
	def count(self):       
    self.__secretCount += 1        
    self.publicCount += 1        
    print (self.__secretCount)  
counter = JustCounter() 
counter.count() 
counter.count() 
print (counter.publicCount) 
print (counter.__secretCount)  # 报错，实例不能访问私有变量
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: 'JustCounter' object has no attribute '__secretCount'
</code></pre>
<p>类的私有方法实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3
 
class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private
 
    def who(self):
        print('name  : ', self.name)
        print('url : ', self.__url)
 
    def __foo(self):          # 私有方法
        print('这是私有方法')
 
    def foo(self):            # 公共方法
        print('这是公共方法')
        self.__foo()
 
x = Site('菜鸟教程', 'www.runoob.com')
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
</code></pre>
<h3 id="类的专有方法"><a class="header" href="#类的专有方法">类的专有方法：</a></h3>
<ul>
<li><strong><strong>init</strong> :</strong> 构造函数，在生成对象时调用</li>
<li><strong><strong>del</strong> :</strong> 析构函数，释放对象时使用</li>
<li><strong><strong>repr</strong> :</strong> 打印，转换</li>
<li><strong><strong>setitem</strong> :</strong> 按照索引赋值</li>
<li><strong><strong>getitem</strong>:</strong> 按照索引获取值</li>
<li><strong><strong>len</strong>:</strong> 获得长度</li>
<li><strong><strong>cmp</strong>:</strong> 比较运算</li>
<li><strong><strong>call</strong>:</strong> 函数调用</li>
<li><strong><strong>add</strong>:</strong> 加运算</li>
<li><strong><strong>sub</strong>:</strong> 减运算</li>
<li><strong><strong>mul</strong>:</strong> 乘运算</li>
<li><strong><strong>truediv</strong>:</strong> 除运算</li>
<li><strong><strong>mod</strong>:</strong> 求余运算</li>
<li><strong><strong>pow</strong>:</strong> 乘方</li>
</ul>
<h3 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h3>
<p>Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class Vector:   
  def __init__(self, a, b):      
    self.a = a      
    self.b = b    
  def __str__(self):      
    return 'Vector (%d, %d)' % (self.a, self.b)      
  def __add__(self,other):      
    return Vector(self.a + other.a, self.b + other.b)  

  v1 = Vector(2,10) 
  v2 = Vector(5,-2) 
  print (v1 + v2)
</code></pre>
<p>以上代码执行结果如下所示:</p>
<pre><code>Vector(7,8)
</code></pre>
<h2 id="单下划线双下划线头尾双下划线说明"><a class="header" href="#单下划线双下划线头尾双下划线说明">单下划线、双下划线、头尾双下划线说明：</a></h2>
<ul>
<li><strong><strong>foo</strong></strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong><strong>init</strong>()</strong> 之类的。</li>
<li><strong>_foo</strong>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li>
<li><strong>__foo</strong>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li>
</ul>
<h2 id="python对象销毁垃圾回收"><a class="header" href="#python对象销毁垃圾回收">python对象销毁(垃圾回收)</a></h2>
<p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。</p>
<p>在 Python 内部记录着所有使用中的对象各有多少引用。</p>
<p>一个内部跟踪变量，称为一个引用计数器。</p>
<p>当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p>
<pre><code class="language-python">a = 40      # 创建对象  &lt;40&gt;
b = a       # 增加引用， &lt;40&gt; 的计数
c = [b]     # 增加引用.  &lt;40&gt; 的计数

del a       # 减少引用 &lt;40&gt; 的计数
b = 100     # 减少引用 &lt;40&gt; 的计数
c[0] = -1   # 减少引用 &lt;40&gt; 的计数

</code></pre>
<p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p>
<h2 id="基础重载方法"><a class="header" href="#基础重载方法">基础重载方法</a></h2>
<p>下表列出了一些通用的功能，你可以在自己的类重写：</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法, 描述 &amp; 简单的调用</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong><strong>init</strong> ( self [,args...] )</strong> 构造函数 简单的调用方法: <em>obj = className(args)</em></td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong><strong>del</strong>( self )</strong> 析构方法, 删除一个对象 简单的调用方法 : <em>del obj</em></td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong><strong>repr</strong>( self )</strong> 转化为供解释器读取的形式 简单的调用方法 : <em>repr(obj)</em></td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong><strong>str</strong>( self )</strong> 用于将值转化为适于人阅读的形式 简单的调用方法 : <em>str(obj)</em></td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong><strong>cmp</strong> ( self, x )</strong> 对象比较 简单的调用方法 : <em>cmp(obj, x)</em></td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../python基础_1_python基础/15.Python3JSON数据解析.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../python基础_1_python基础/17.模块与包.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../python基础_1_python基础/15.Python3JSON数据解析.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../python基础_1_python基础/17.模块与包.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
