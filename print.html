<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title">python基础</li><li class="chapter-item expanded "><a href="python基础_1_python基础/index.html"><strong aria-hidden="true">1.</strong> python基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python基础_1_python基础/1.python3基础语法.html"><strong aria-hidden="true">1.1.</strong> python3基础语法</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/2.基本数据类型.html"><strong aria-hidden="true">1.2.</strong> 基本数据类型</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/3.Python3数据类型转换.html"><strong aria-hidden="true">1.3.</strong> Python3数据类型转换</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/4.Python推导式.html"><strong aria-hidden="true">1.4.</strong> Python推导式</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/5.Python3运算符.html"><strong aria-hidden="true">1.5.</strong> Python3运算符</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/6.Python3字符串.html"><strong aria-hidden="true">1.6.</strong> Python3字符串</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/7.python3列表.html"><strong aria-hidden="true">1.7.</strong> python3列表</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/8.元祖.html"><strong aria-hidden="true">1.8.</strong> 元祖</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/9.Python3字典.html"><strong aria-hidden="true">1.9.</strong> Python3字典</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/10.Python3集合.html"><strong aria-hidden="true">1.10.</strong> Python3集合</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/11.Number类型.html"><strong aria-hidden="true">1.11.</strong> Number类型</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/12.python3流程控制.html"><strong aria-hidden="true">1.12.</strong> python3流程控制</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/13.Python3迭代器与生成器.html"><strong aria-hidden="true">1.13.</strong> Python3迭代器与生成器</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/14.函数.html"><strong aria-hidden="true">1.14.</strong> 函数</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/15.Python3JSON数据解析.html"><strong aria-hidden="true">1.15.</strong> Python3JSON数据解析</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/16.Python3面向对象.html"><strong aria-hidden="true">1.16.</strong> Python3面向对象</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/17.模块与包.html"><strong aria-hidden="true">1.17.</strong> 模块与包</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/With关键字.html"><strong aria-hidden="true">1.18.</strong> With关键字</a></li><li class="chapter-item expanded "><a href="python基础_1_python基础/杂项.html"><strong aria-hidden="true">1.19.</strong> 杂项</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">python三方库</li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> fabric</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="python三方库_2_fabric/fabric/index.html"><strong aria-hidden="true">2.1.</strong> fabric</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python三方库_2_fabric/fabric/Configuration.html"><strong aria-hidden="true">2.1.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="python三方库_2_fabric/fabric/README_1.x.html"><strong aria-hidden="true">2.1.2.</strong> README_1.x</a></li></ol></li><li class="chapter-item expanded "><a href="python三方库_2_fabric/invoke/index.html"><strong aria-hidden="true">2.2.</strong> invoke</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python三方库_2_fabric/invoke/1.DefiningAndRunningTask.html"><strong aria-hidden="true">2.2.1.</strong> DefiningAndRunningTask</a></li><li class="chapter-item expanded "><a href="python三方库_2_fabric/invoke/2.InvokeCoreUsage.html"><strong aria-hidden="true">2.2.2.</strong> InvokeCoreUsage</a></li><li class="chapter-item expanded "><a href="python三方库_2_fabric/invoke/3.Configuration.html"><strong aria-hidden="true">2.2.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="python三方库_2_fabric/invoke/4.loadingCollections.html"><strong aria-hidden="true">2.2.4.</strong> loadingCollections</a></li><li class="chapter-item expanded "><a href="python三方库_2_fabric/invoke/5.UsingInvokeAslibrary.html"><strong aria-hidden="true">2.2.5.</strong> UsingInvokeAslibrary</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="python笔记库"><a class="header" href="#python笔记库">Python笔记库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>Python库</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="编码"><a class="header" href="#编码">编码</a></h2>
<p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p>
<pre><code># -*- coding: cp-1252 -*-
</code></pre>
<h2 id="标识符"><a class="header" href="#标识符">标识符</a></h2>
<ul>
<li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</p>
<h2 id="python保留字"><a class="header" href="#python保留字">python保留字</a></h2>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p>
<pre><code class="language-shell">&gt;&gt;&gt; import keyword
&gt;&gt;&gt; keyword.kwlist
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<p>Python中单行注释以 <strong>#</strong> 开头，实例如下：</p>
<p>多行注释可以用多个 <strong>#</strong> 号，还有 <strong>'''</strong> 和 <strong>&quot;&quot;&quot;</strong>：</p>
<pre><code class="language-python">'''
第三注释
第四注释
'''

</code></pre>
<h2 id="行与缩进"><a class="header" href="#行与缩进">行与缩进</a></h2>
<p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p>
<pre><code class="language-python">if True:
    print (&quot;True&quot;)
else:
    print (&quot;False&quot;)
</code></pre>
<p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 *<em>*</em> 来实现多行语句，例如：</p>
<pre><code class="language-python">total = item_one + \
        item_two + \
        item_three
</code></pre>
<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如：</p>
<pre><code class="language-python">total = ['item_one', 'item_two', 'item_three',
        'item_four', 'item_five']
</code></pre>
<h2 id="数字number类型"><a class="header" href="#数字number类型">数字(Number)类型</a></h2>
<p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li><strong>bool</strong> (布尔), 如 True。</li>
<li><strong>float</strong> (浮点数), 如 1.23、3E-2</li>
<li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h2 id="字符串string"><a class="header" href="#字符串string">字符串(String)</a></h2>
<ul>
<li>Python 中单引号 <strong>'</strong> 和双引号 <strong>&quot;</strong> 使用完全相同。</li>
<li>使用三引号(<strong>'''</strong> 或 <strong>&quot;&quot;&quot;</strong>)可以指定一个多行字符串。</li>
<li>转义符 ****。</li>
<li>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r&quot;this is a line with \n&quot;</strong> 则 <strong>\n</strong> 会显示，并不是换行。</li>
<li>按字面意义级联字符串，如 <strong>&quot;this &quot; &quot;is &quot; &quot;string&quot;</strong> 会被自动转换为 <strong>this is string</strong>。</li>
<li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</li>
<li>Python 中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong>   头下标是 inclusive，尾下标 是 exclusive</li>
</ul>
<h2 id="等待用户输入"><a class="header" href="#等待用户输入">等待用户输入</a></h2>
<pre><code class="language-python">input(&quot;\n\n按下 enter 键后退出。&quot;)
</code></pre>
<h2 id="同一行显示多条语句"><a class="header" href="#同一行显示多条语句">同一行显示多条语句</a></h2>
<pre><code class="language-python">import sys; x = 'runoob'; sys.stdout.write(x + '\n')
</code></pre>
<h2 id="print-输出"><a class="header" href="#print-输出">print 输出</a></h2>
<pre><code class="language-python"> 
x=&quot;a&quot;
y=&quot;b&quot;
# 换行输出
print( x )
print( y )
 
print('---------')
# 不换行输出
print( x, end=&quot; &quot; )
print( y, end=&quot; &quot; )
print()
</code></pre>
<h2 id="import-与-fromimport"><a class="header" href="#import-与-fromimport">import 与 from...import</a></h2>
<p>在 python 用 <strong>import</strong> 或者 <strong>from...import</strong> 来导入相应的模块。</p>
<p>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></p>
<p>从某个模块中导入某个函数,格式为： <strong>from somemodule import somefunction</strong></p>
<p>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p>
<p>将某个模块中的全部函数导入，格式为： <strong>from somemodule import *</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-基本数据类型"><a class="header" href="#python3-基本数据类型">Python3 基本数据类型</a></h1>
<p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的&quot;类型&quot;是变量所指的内存中对象的类型。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：</p>
<pre><code class="language-python">
counter = 100          # 整型变量
miles   = 1000.0       # 浮点型变量
name    = &quot;runoob&quot;     # 字符串

print (counter)
print (miles)
print (name)
</code></pre>
<h3 id="多个变量赋值"><a class="header" href="#多个变量赋值">多个变量赋值</a></h3>
<pre><code class="language-python">a = b = c = 1
</code></pre>
<p>以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p>
<p>您也可以为多个对象指定多个变量。例如：</p>
<pre><code class="language-python">a, b, c = 1, 2, &quot;runoob&quot;

</code></pre>
<h2 id="标准数据类型"><a class="header" href="#标准数据类型">标准数据类型</a></h2>
<p>​	Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<h2 id="number数字"><a class="header" href="#number数字">Number（数字）</a></h2>
<ol>
<li>
<p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p>
</li>
<li>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
</li>
<li>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
</li>
</ol>
<pre><code class="language-python">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j
&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))
&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt;
</code></pre>
<p>此外还可以用 isinstance 来判断：</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 111
&gt;&gt;&gt; isinstance(a, int)
True
&gt;&gt;&gt;
</code></pre>
<p>isinstance 和 type 的区别在于：</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<p>**注意：**Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， <strong>True==1、False==0</strong> 会返回 <strong>True</strong>，但可以通过 <strong>issubclass</strong> 来判断类型。</p>
<p>当你指定一个值时，Number 对象就会被创建：</p>
<pre><code class="language-python">var1 = 1
var2 = 10
</code></pre>
<p>您也可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<pre><code class="language-python">del var1[,var2[,var3[....,varN]]]
</code></pre>
<h3 id="数值运算"><a class="header" href="#数值运算">数值运算</a></h3>
<pre><code class="language-python">&gt;&gt;&gt; 5 + 4  # 加法
9
&gt;&gt;&gt; 4.3 - 2 # 减法
2.3
&gt;&gt;&gt; 3 * 7  # 乘法
21
&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数
0.5
&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数
0
&gt;&gt;&gt; 17 % 3 # 取余
2
&gt;&gt;&gt; 2 ** 5 # 乘方
32
</code></pre>
<p>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</p>
<p>2、一个变量可以通过赋值指向不同类型的对象。</p>
<p>3、数值的除法包含两个运算符：<strong>/</strong> 返回一个浮点数，<strong>//</strong> 返回一个整数。</p>
<p>4、在混合计算时，Python会把整型转换成为浮点数。</p>
<h3 id="数值类型实例"><a class="header" href="#数值类型实例">数值类型实例</a></h3>
<table><thead><tr><th style="text-align: left">int</th><th style="text-align: left">float</th><th style="text-align: left">complex</th></tr></thead><tbody>
<tr><td style="text-align: left">10</td><td style="text-align: left">0.0</td><td style="text-align: left">3.14j</td></tr>
<tr><td style="text-align: left">100</td><td style="text-align: left">15.20</td><td style="text-align: left">45.j</td></tr>
<tr><td style="text-align: left">-786</td><td style="text-align: left">-21.9</td><td style="text-align: left">9.322e-36j</td></tr>
<tr><td style="text-align: left">080</td><td style="text-align: left">32.3e+18</td><td style="text-align: left">.876j</td></tr>
<tr><td style="text-align: left">-0490</td><td style="text-align: left">-90.</td><td style="text-align: left">-.6545+0J</td></tr>
<tr><td style="text-align: left">-0x260</td><td style="text-align: left">-32.54e100</td><td style="text-align: left">3e+26J</td></tr>
<tr><td style="text-align: left">0x69</td><td style="text-align: left">70.2E-12</td><td style="text-align: left">4.53e-7j</td></tr>
</tbody></table>
<p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
<h2 id="string字符串"><a class="header" href="#string字符串">String（字符串）</a></h2>
<p>Python中的字符串用单引号 <strong>'</strong> 或双引号 <strong>&quot;</strong> 括起来，同时使用反斜杠 *<em>*</em> 转义特殊字符。</p>
<ul>
<li>加号 <strong>+</strong> 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。实例如下：</li>
<li>Python 使用反斜杠 *<em>*</em> 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 <strong>r</strong>，表示原始字符串：</li>
<li>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>&quot;&quot;&quot;...&quot;&quot;&quot;</strong> 或者 <strong>'''...'''</strong> 跨越多行。</li>
<li>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</li>
<li>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。</li>
</ul>
<h2 id="list列表"><a class="header" href="#list列表">List（列表）</a></h2>
<ul>
<li>
<p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p>
</li>
<li>
<p>索引值以 <strong>0</strong> 为开始值，<strong>-1</strong> 为从末尾的开始位置。和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。列表截取的语法格式如下：<code>变量[头下标:尾下标]</code></p>
</li>
<li>
<p>索引值以 <strong>0</strong> 为开始值，<strong>-1</strong> 为从末尾的开始位置。</p>
</li>
<li>
<p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p>
<pre><code class="language-python">#!/usr/bin/python3

list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]
tinylist = [123, 'runoob']

print (list)            # 输出完整列表
print (list[0])         # 输出列表第一个元素
print (list[1:3])       # 从第二个开始输出到第三个元素
print (list[2:])        # 输出从第三个元素开始的所有元素
print (tinylist * 2)    # 输出两次列表
print (list + tinylist) # 连接列表
</code></pre>
</li>
<li>
<p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
</li>
<li>
<p>1、List写在方括号之间，元素用逗号隔开。</p>
</li>
<li>
<p>2、和字符串一样，list可以被索引和切片。</p>
</li>
<li>
<p>3、List可以使用+操作符进行拼接。</p>
</li>
<li>
<p>4、List中的元素是可以改变的</p>
</li>
</ul>
<p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p>
<p>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p>
<pre><code class="language-python">def reverseWords(input):
     
    # 通过空格将字符串分隔符，把各个单词分隔为列表
    inputWords = input.split(&quot; &quot;)
 
    # 翻转字符串
    # 假设列表 list = [1,2,3,4],  
    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)
    # inputWords[-1::-1] 有三个参数
    # 第一个参数 -1 表示最后一个元素
    # 第二个参数为空，表示移动到列表末尾
    # 第三个参数为步长，-1 表示逆向
    inputWords=inputWords[-1::-1]
 
    # 重新组合字符串
    output = ' '.join(inputWords)
     
    return output
 
if __name__ == &quot;__main__&quot;:
    input = 'I like runoob'
    rw = reverseWords(input)
    print(rw)
</code></pre>
<h2 id="tuple元组"><a class="header" href="#tuple元组">Tuple（元组）</a></h2>
<p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<pre><code class="language-python">#!/usr/bin/python3

tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
tinytuple = (123, 'runoob')

print (tuple)             # 输出完整元组
print (tuple[0])          # 输出元组的第一个元素
print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
print (tuple[2:])         # 输出从第三个元素开始的所有元素
print (tinytuple * 2)     # 输出两次元组
print (tuple + tinytuple) # 连接元组
</code></pre>
<p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p>
<p>其实，可以把字符串看作一种特殊的元组。</p>
<ul>
<li>1、与字符串一样，元组的元素不能修改。</li>
<li>2、元组也可以被索引和切片，方法一样。</li>
<li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li>
<li>4、元组也可以使用+操作符进行拼接。</li>
</ul>
<h2 id="set集合"><a class="header" href="#set集合">Set（集合）</a></h2>
<p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<pre><code class="language-python">parame = {value01,value02,...}
或者
set(value)
</code></pre>
<pre><code class="language-python">#!/usr/bin/python3

sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}

print(sites)   # 输出集合，重复的元素被自动去掉

# 成员测试
if 'Runoob' in sites :
    print('Runoob 在集合中')
else :
    print('Runoob 不在集合中')


# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam')

print(a)

print(a - b)     # a 和 b 的差集

print(a | b)     # a 和 b 的并集

print(a &amp; b)     # a 和 b 的交集

print(a ^ b)     # a 和 b 中不同时存在的元素
</code></pre>
<h2 id="dictionary字典"><a class="header" href="#dictionary字典">Dictionary（字典）</a></h2>
<p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<pre><code class="language-python">#!/usr/bin/python3

dict = {}
dict['one'] = &quot;1 - 菜鸟教程&quot;
dict[2]     = &quot;2 - 菜鸟工具&quot;

tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}


print (dict['one'])       # 输出键为 'one' 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
</code></pre>
<p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
{'Runoob': 1, 'Google': 2, 'Taobao': 3}
&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)
{'Runoob': 1, 'Google': 2, 'Taobao': 3}
</code></pre>
<p>该代码使用的是字典推导式，更多推导式内容可以参考：<a href="https://www.runoob.com/python3/python-comprehensions.html">Python 推导式</a>。</p>
<pre><code class="language-python">{x: x**2 for x in (2, 4, 6)}
</code></pre>
<p>另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。</p>
<ul>
<li>1、字典是一种映射类型，它的元素是键值对。</li>
<li>2、字典的关键字必须为不可变类型，且不能重复。</li>
<li>3、创建空字典使用 <strong>{ }</strong>。</li>
</ul>
<h2 id="python数据类型转换"><a class="header" href="#python数据类型转换">Python数据类型转换</a></h2>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，在下一章节 <a href="https://www.runoob.com/python3/python3-type-conversion.html">Python3 数据类型转换</a> 会具体介绍。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table><thead><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td style="text-align: left">将x转换为一个整数</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td style="text-align: left">将x转换到一个浮点数</td></tr>
<tr><td style="text-align: left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td style="text-align: left">创建一个复数</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td style="text-align: left">将对象 x 转换为字符串</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td style="text-align: left">将对象 x 转换为表达式字符串</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td style="text-align: left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td style="text-align: left">将序列 s 转换为一个元组</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td style="text-align: left">将序列 s 转换为一个列表</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td style="text-align: left">转换为可变集合</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td style="text-align: left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td style="text-align: left">转换为不可变集合</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td style="text-align: left">将一个整数转换为一个字符</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td style="text-align: left">将一个字符转换为它的整数值</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td style="text-align: left">将一个整数转换为一个十六进制字符串</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td style="text-align: left">将一个整数转换为一个八进制字符串</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-数据类型转换"><a class="header" href="#python3-数据类型转换">Python3 数据类型转换</a></h1>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。</p>
<p>Python 数据类型转换可以分为两种：</p>
<ul>
<li>隐式类型转换 - 自动完成</li>
<li>显式类型转换 - 需要使用类型函数来转换</li>
</ul>
<p>​	</p>
<h3 id="隐式类型转换"><a class="header" href="#隐式类型转换">隐式类型转换</a></h3>
<p>在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。</p>
<p>以下实例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。</p>
<pre><code class="language-python">
num_int = 123
num_flo = 1.23

num_new = num_int + num_flo

print(&quot;datatype of num_int:&quot;,type(num_int))
print(&quot;datatype of num_flo:&quot;,type(num_flo))

print(&quot;Value of num_new:&quot;,num_new)
print(&quot;datatype of num_new:&quot;,type(num_new))
</code></pre>
<pre><code>num_int 数据类型为: &lt;class 'int'&gt;
num_flo 数据类型为: &lt;class 'float'&gt;
num_new: 值为: 124.23
num_new 数据类型为: &lt;class 'float'&gt;
</code></pre>
<h3 id="显式类型转换"><a class="header" href="#显式类型转换">显式类型转换</a></h3>
<p>在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。</p>
<pre><code class="language-python">num_int = 123
num_str = &quot;456&quot;

print(&quot;Data type of num_int:&quot;,type(num_int))
print(&quot;Data type of num_str:&quot;,type(num_str))

print(num_int+num_str)
</code></pre>
<h4 id="实例"><a class="header" href="#实例">实例</a></h4>
<p><strong>int()</strong> 强制转换为整型：</p>
<pre><code class="language-python">x = int(1)  # x 输出结果为 1
y = int(2.8) # y 输出结果为 2
z = int(&quot;3&quot;) # z 输出结果为 3
</code></pre>
<p><strong>float()</strong> 强制转换为浮点型：</p>
<h4 id="实例-1"><a class="header" href="#实例-1">实例</a></h4>
<pre><code class="language-python">x = float(1)   # x 输出结果为 1.0
y = float(2.8)  # y 输出结果为 2.8
z = float(&quot;3&quot;)  # z 输出结果为 3.0
w = float(&quot;4.2&quot;) # w 输出结果为 4.2
</code></pre>
<p><strong>str()</strong> 强制转换为字符串类型：</p>
<h4 id="实例-2"><a class="header" href="#实例-2">实例</a></h4>
<pre><code class="language-python">x = str(&quot;s1&quot;) # x 输出结果为 's1'
y = str(2)   # y 输出结果为 '2'
z = str(3.0) # z 输出结果为 '3.0'
</code></pre>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table><thead><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td style="text-align: left">将x转换为一个整数</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td style="text-align: left">将x转换到一个浮点数</td></tr>
<tr><td style="text-align: left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td style="text-align: left">创建一个复数</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td style="text-align: left">将对象 x 转换为字符串</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td style="text-align: left">将对象 x 转换为表达式字符串</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td style="text-align: left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td style="text-align: left">将序列 s 转换为一个元组</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td style="text-align: left">将序列 s 转换为一个列表</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td style="text-align: left">转换为可变集合</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td style="text-align: left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td style="text-align: left">转换为不可变集合</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td style="text-align: left">将一个整数转换为一个字符</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td style="text-align: left">将一个字符转换为它的整数值</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td style="text-align: left">将一个整数转换为一个十六进制字符串</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td style="text-align: left">将一个整数转换为一个八进制字符串</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-推导式"><a class="header" href="#python-推导式">Python 推导式</a></h1>
<p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
<li>元组(tuple)推导式</li>
</ul>
<h2 id="列表推导式"><a class="header" href="#列表推导式">列表推导式</a></h2>
<p>列表推导式格式为：</p>
<pre><code class="language-python">[表达式 for 变量 in 列表] 
[out_exp_res for out_exp in input_list]

或者 

[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]
</code></pre>
<ul>
<li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li>
<li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li>
<li>if condition：条件语句，可以过滤列表中不符合条件的值。</li>
</ul>
<p>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<pre><code class="language-python">&gt;&gt;&gt; names = ['Bob','Tom','alice','Jerry','Wendy','Smith']
&gt;&gt;&gt; new_names = [name.upper()for name in names if len(name)&gt;3]
&gt;&gt;&gt; print(new_names)
['ALICE', 'JERRY', 'WENDY', 'SMITH']
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; multiples = [i for i in range(30) if i % 3 == 0]
&gt;&gt;&gt; print(multiples)
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
</code></pre>
<h2 id="字典推导式"><a class="header" href="#字典推导式">字典推导式</a></h2>
<pre><code class="language-python">{ key_expr: value_expr for value in collection }

或

{ key_expr: value_expr for value in collection if condition }

</code></pre>
<pre><code class="language-python">listdemo = ['Google','Runoob', 'Taobao']
# 将列表中各字符串值为键，各字符串的长度为值，组成键值对
&gt;&gt;&gt; newdict = {key:len(key) for key in listdemo}
&gt;&gt;&gt; newdict
{'Google': 6, 'Runoob': 6, 'Taobao': 6}

</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; dic = {x: x**2 for x in (2, 4, 6)}
&gt;&gt;&gt; dic
{2: 4, 4: 16, 6: 36}
&gt;&gt;&gt; type(dic)
&lt;class 'dict'&gt;
</code></pre>
<h2 id="set推导式"><a class="header" href="#set推导式">Set推导式</a></h2>
<pre><code class="language-python">{ expression for item in Sequence }
或
{ expression for item in Sequence if conditional }
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; setnew = {i**2 for i in (1,2,3)}
&gt;&gt;&gt; setnew
{1, 4, 9}
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; a = {x for x in 'abracadabra' if x not in 'abc'}
&gt;&gt;&gt; a
{'d', 'r'}
&gt;&gt;&gt; type(a)
&lt;class 'set'&gt;
</code></pre>
<h2 id="元组推导式"><a class="header" href="#元组推导式">元组推导式</a></h2>
<pre><code class="language-python">(expression for item in Sequence )
或
(expression for item in Sequence if conditional )
</code></pre>
<p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <strong>()</strong> 圆括号将各部分括起来，而列表推导式用的是中括号 <strong>[]</strong>，另外元组推导式返回的结果是一个生成器对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-运算符"><a class="header" href="#python3-运算符">Python3 运算符</a></h1>
<p>Python 语言支持以下类型的运算符:</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf1">算术运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf2">比较（关系）运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf3">赋值运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf4">逻辑运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf5">位运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf6">成员运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf7">身份运算符</a></li>
<li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf8">运算符优先级</a></li>
</ul>
<h2 id="python算术运算符"><a class="header" href="#python算术运算符">Python算术运算符</a></h2>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">+</td><td style="text-align: left">加 - 两个对象相加</td><td style="text-align: left">a + b 输出结果 31</td></tr>
<tr><td style="text-align: left">-</td><td style="text-align: left">减 - 得到负数或是一个数减去另一个数</td><td style="text-align: left">a - b 输出结果 -11</td></tr>
<tr><td style="text-align: left">*</td><td style="text-align: left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td style="text-align: left">a * b 输出结果 210</td></tr>
<tr><td style="text-align: left">/</td><td style="text-align: left">除 - x 除以 y</td><td style="text-align: left">b / a 输出结果 2.1</td></tr>
<tr><td style="text-align: left">%</td><td style="text-align: left">取模 - 返回除法的余数</td><td style="text-align: left">b % a 输出结果 1</td></tr>
<tr><td style="text-align: left">**</td><td style="text-align: left">幂 - 返回x的y次幂</td><td style="text-align: left">a**b 为10的21次方</td></tr>
<tr><td style="text-align: left">//</td><td style="text-align: left">取整除 - 向下取接近商的整数</td><td style="text-align: left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr>
</tbody></table>
<p>以下实例演示了Python所有算术运算符的操作：</p>
<h2 id="python比较运算符"><a class="header" href="#python比较运算符">Python比较运算符</a></h2>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">==</td><td style="text-align: left">等于 - 比较对象是否相等</td><td style="text-align: left">(a == b) 返回 False。</td></tr>
<tr><td style="text-align: left">!=</td><td style="text-align: left">不等于 - 比较两个对象是否不相等</td><td style="text-align: left">(a != b) 返回 True。</td></tr>
<tr><td style="text-align: left">&gt;</td><td style="text-align: left">大于 - 返回x是否大于y</td><td style="text-align: left">(a &gt; b) 返回 False。</td></tr>
<tr><td style="text-align: left">&lt;</td><td style="text-align: left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td style="text-align: left">(a &lt; b) 返回 True。</td></tr>
<tr><td style="text-align: left">&gt;=</td><td style="text-align: left">大于等于 - 返回x是否大于等于y。</td><td style="text-align: left">(a &gt;= b) 返回 False。</td></tr>
<tr><td style="text-align: left">&lt;=</td><td style="text-align: left">小于等于 - 返回x是否小于等于y。</td><td style="text-align: left">(a &lt;= b) 返回 True。</td></tr>
</tbody></table>
<h2 id="python赋值运算符"><a class="header" href="#python赋值运算符">Python赋值运算符</a></h2>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">=</td><td style="text-align: left">简单的赋值运算符</td><td style="text-align: left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr>
<tr><td style="text-align: left">+=</td><td style="text-align: left">加法赋值运算符</td><td style="text-align: left">c += a 等效于 c = c + a</td></tr>
<tr><td style="text-align: left">-=</td><td style="text-align: left">减法赋值运算符</td><td style="text-align: left">c -= a 等效于 c = c - a</td></tr>
<tr><td style="text-align: left">*=</td><td style="text-align: left">乘法赋值运算符</td><td style="text-align: left">c *= a 等效于 c = c * a</td></tr>
<tr><td style="text-align: left">/=</td><td style="text-align: left">除法赋值运算符</td><td style="text-align: left">c /= a 等效于 c = c / a</td></tr>
<tr><td style="text-align: left">%=</td><td style="text-align: left">取模赋值运算符</td><td style="text-align: left">c %= a 等效于 c = c % a</td></tr>
<tr><td style="text-align: left">**=</td><td style="text-align: left">幂赋值运算符</td><td style="text-align: left">c **= a 等效于 c = c ** a</td></tr>
<tr><td style="text-align: left">//=</td><td style="text-align: left">取整除赋值运算符</td><td style="text-align: left">c //= a 等效于 c = c // a</td></tr>
<tr><td style="text-align: left">:=</td><td style="text-align: left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td style="text-align: left">在这个示例中，赋值表达式可以避免调用 len() 两次:<code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long ({n} elements, expected &lt;= 10)&quot;)</code></td></tr>
</tbody></table>
<h2 id="python位运算符"><a class="header" href="#python位运算符">Python位运算符</a></h2>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">&amp;</td><td style="text-align: left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td style="text-align: left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr>
<tr><td style="text-align: left">|</td><td style="text-align: left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td style="text-align: left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr>
<tr><td style="text-align: left">^</td><td style="text-align: left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td style="text-align: left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr>
<tr><td style="text-align: left">~</td><td style="text-align: left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。<strong>~x</strong> 类似于 <strong>-x-1</strong></td><td style="text-align: left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr>
<tr><td style="text-align: left">&lt;&lt;</td><td style="text-align: left">左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align: left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr>
<tr><td style="text-align: left">&gt;&gt;</td><td style="text-align: left">右移动运算符：把&quot;&gt;&gt;&quot;左边的运算数的各二进位全部右移若干位，&quot;&gt;&gt;&quot;右边的数指定移动的位数</td><td style="text-align: left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr>
</tbody></table>
<h2 id="python逻辑运算符"><a class="header" href="#python逻辑运算符">Python逻辑运算符</a></h2>
<p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">逻辑表达式</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">and</td><td style="text-align: left">x and y</td><td style="text-align: left">布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td style="text-align: left">(a and b) 返回 20。</td></tr>
<tr><td style="text-align: left">or</td><td style="text-align: left">x or y</td><td style="text-align: left">布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td style="text-align: left">(a or b) 返回 10。</td></tr>
<tr><td style="text-align: left">not</td><td style="text-align: left">not x</td><td style="text-align: left">布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td style="text-align: left">not(a and b) 返回 False</td></tr>
</tbody></table>
<h2 id="python成员运算符"><a class="header" href="#python成员运算符">Python成员运算符</a></h2>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">in</td><td style="text-align: left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td style="text-align: left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr>
<tr><td style="text-align: left">not in</td><td style="text-align: left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td style="text-align: left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr>
</tbody></table>
<h2 id="python身份运算符"><a class="header" href="#python身份运算符">Python身份运算符</a></h2>
<p>身份运算符用于比较两个对象的存储单元</p>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">is</td><td style="text-align: left">is 是判断两个标识符是不是引用自一个对象</td><td style="text-align: left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr>
<tr><td style="text-align: left">is not</td><td style="text-align: left">is not 是判断两个标识符是不是引用自不同对象</td><td style="text-align: left"><strong>x is not y</strong> ， 类似 <strong>id(x) != id(y)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr>
</tbody></table>
<h2 id="python运算符优先级"><a class="header" href="#python运算符优先级">Python运算符优先级</a></h2>
<p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">**</td><td style="text-align: left">指数 (最高优先级)</td></tr>
<tr><td style="text-align: left">~ + -</td><td style="text-align: left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr>
<tr><td style="text-align: left">* / % //</td><td style="text-align: left">乘，除，求余数和取整除</td></tr>
<tr><td style="text-align: left">+ -</td><td style="text-align: left">加法减法</td></tr>
<tr><td style="text-align: left">&gt;&gt; &lt;&lt;</td><td style="text-align: left">右移，左移运算符</td></tr>
<tr><td style="text-align: left">&amp;</td><td style="text-align: left">位 'AND'</td></tr>
<tr><td style="text-align: left">^ |</td><td style="text-align: left">位运算符</td></tr>
<tr><td style="text-align: left">&lt;= &lt; &gt; &gt;=</td><td style="text-align: left">比较运算符</td></tr>
<tr><td style="text-align: left">== !=</td><td style="text-align: left">等于运算符</td></tr>
<tr><td style="text-align: left">= %= /= //= -= += *= **=</td><td style="text-align: left">赋值运算符</td></tr>
<tr><td style="text-align: left">is is not</td><td style="text-align: left">身份运算符</td></tr>
<tr><td style="text-align: left">in not in</td><td style="text-align: left">成员运算符</td></tr>
<tr><td style="text-align: left">not and or</td><td style="text-align: left">逻辑运算符</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-字符串"><a class="header" href="#python3-字符串">Python3 字符串</a></h1>
<p>字符串是 Python 中最常用的数据类型。我们可以使用引号( <strong>'</strong> 或 <strong>&quot;</strong> )来创建字符串。</p>
<p>创建字符串很简单，只要为变量分配一个值即可。例如：</p>
<h2 id="python-访问字符串中的值"><a class="header" href="#python-访问字符串中的值">Python 访问字符串中的值</a></h2>
<pre><code class="language-python">变量[头下标:尾下标]
</code></pre>
<h2 id="python转义字符"><a class="header" href="#python转义字符">Python转义字符</a></h2>
<p>在需要在字符中使用特殊字符时，python 用反斜杠 *<em>*</em> 转义字符。如下表：</p>
<table><thead><tr><th style="text-align: left">转义字符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">\(在行尾时)</td><td style="text-align: left">续行符</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;line1 \ ... line2 \ ... line3&quot;) line1 line2 line3 &gt;&gt;&gt; </code></td></tr>
<tr><td style="text-align: left">\\</td><td style="text-align: left">反斜杠符号</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\\&quot;) \</code></td></tr>
<tr><td style="text-align: left">\'</td><td style="text-align: left">单引号</td><td style="text-align: left"><code>&gt;&gt;&gt; print('\'') '</code></td></tr>
<tr><td style="text-align: left">\&quot;</td><td style="text-align: left">双引号</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\&quot;&quot;) &quot;</code></td></tr>
<tr><td style="text-align: left">\a</td><td style="text-align: left">响铃</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\a&quot;)</code>执行后电脑有响声。</td></tr>
<tr><td style="text-align: left">\b</td><td style="text-align: left">退格(Backspace)</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;Hello \b World!&quot;) Hello World!</code></td></tr>
<tr><td style="text-align: left">\000</td><td style="text-align: left">空</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\000&quot;) &gt;&gt;&gt; </code></td></tr>
<tr><td style="text-align: left">\n</td><td style="text-align: left">换行</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\n&quot;)  &gt;&gt;&gt;</code></td></tr>
<tr><td style="text-align: left">\v</td><td style="text-align: left">纵向制表符</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;Hello \v World!&quot;) Hello        World! &gt;&gt;&gt;</code></td></tr>
<tr><td style="text-align: left">\t</td><td style="text-align: left">横向制表符</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;Hello \t World!&quot;) Hello    World! &gt;&gt;&gt;</code></td></tr>
<tr><td style="text-align: left">\r</td><td style="text-align: left">回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成。</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;Hello\rWorld!&quot;) World! &gt;&gt;&gt; print('google runoob taobao\r123456') 123456 runoob taobao</code></td></tr>
<tr><td style="text-align: left">\f</td><td style="text-align: left">换页</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;Hello \f World!&quot;) Hello        World! &gt;&gt;&gt; </code></td></tr>
<tr><td style="text-align: left">\yyy</td><td style="text-align: left">八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\110\145\154\154\157\40\127\157\162\154\144\41&quot;) Hello World!</code></td></tr>
<tr><td style="text-align: left">\xyy</td><td style="text-align: left">十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td><td style="text-align: left"><code>&gt;&gt;&gt; print(&quot;\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21&quot;) Hello World!</code></td></tr>
<tr><td style="text-align: left">\other</td><td style="text-align: left">其它的字符以普通格式输出</td><td style="text-align: left"></td></tr>
</tbody></table>
<h2 id="python字符串运算符"><a class="header" href="#python字符串运算符">Python字符串运算符</a></h2>
<p>下表实例变量 a 值为字符串 &quot;Hello&quot;，b 变量值为 &quot;Python&quot;：</p>
<table><thead><tr><th style="text-align: left">操作符</th><th style="text-align: left">描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">+</td><td style="text-align: left">字符串连接</td><td style="text-align: left">a + b 输出结果： HelloPython</td></tr>
<tr><td style="text-align: left">*</td><td style="text-align: left">重复输出字符串</td><td style="text-align: left">a*2 输出结果：HelloHello</td></tr>
<tr><td style="text-align: left">[]</td><td style="text-align: left">通过索引获取字符串中字符</td><td style="text-align: left">a[1] 输出结果 <strong>e</strong></td></tr>
<tr><td style="text-align: left">[ : ]</td><td style="text-align: left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td><td style="text-align: left">a[1:4] 输出结果 <strong>ell</strong></td></tr>
<tr><td style="text-align: left">in</td><td style="text-align: left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td style="text-align: left"><strong>'H' in a</strong> 输出结果 True</td></tr>
<tr><td style="text-align: left">not in</td><td style="text-align: left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td style="text-align: left"><strong>'M' not in a</strong> 输出结果 True</td></tr>
<tr><td style="text-align: left">r/R</td><td style="text-align: left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td style="text-align: left"><code>print( r'\n' ) print( R'\n' )</code></td></tr>
<tr><td style="text-align: left">%</td><td style="text-align: left">格式字符串</td><td style="text-align: left">请看下一节内容。</td></tr>
</tbody></table>
<h2 id="python-字符串格式化"><a class="header" href="#python-字符串格式化">Python 字符串格式化</a></h2>
<p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p>
<pre><code class="language-python">print (&quot;我叫 %s 今年 %d 岁!&quot; % ('小明', 10))
</code></pre>
<p>python字符串格式化符号:</p>
<table><thead><tr><th style="text-align: left">符  号</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">%c</td><td style="text-align: left">格式化字符及其ASCII码</td></tr>
<tr><td style="text-align: left">%s</td><td style="text-align: left">格式化字符串</td></tr>
<tr><td style="text-align: left">%d</td><td style="text-align: left">格式化整数</td></tr>
<tr><td style="text-align: left">%u</td><td style="text-align: left">格式化无符号整型</td></tr>
<tr><td style="text-align: left">%o</td><td style="text-align: left">格式化无符号八进制数</td></tr>
<tr><td style="text-align: left">%x</td><td style="text-align: left">格式化无符号十六进制数</td></tr>
<tr><td style="text-align: left">%X</td><td style="text-align: left">格式化无符号十六进制数（大写）</td></tr>
<tr><td style="text-align: left">%f</td><td style="text-align: left">格式化浮点数字，可指定小数点后的精度</td></tr>
<tr><td style="text-align: left">%e</td><td style="text-align: left">用科学计数法格式化浮点数</td></tr>
<tr><td style="text-align: left">%E</td><td style="text-align: left">作用同%e，用科学计数法格式化浮点数</td></tr>
<tr><td style="text-align: left">%g</td><td style="text-align: left">%f和%e的简写</td></tr>
<tr><td style="text-align: left">%G</td><td style="text-align: left">%f 和 %E 的简写</td></tr>
<tr><td style="text-align: left">%p</td><td style="text-align: left">用十六进制数格式化变量的地址</td></tr>
</tbody></table>
<p>格式化操作符辅助指令:</p>
<table><thead><tr><th style="text-align: left">符号</th><th style="text-align: left">功能</th></tr></thead><tbody>
<tr><td style="text-align: left">*</td><td style="text-align: left">定义宽度或者小数点精度</td></tr>
<tr><td style="text-align: left">-</td><td style="text-align: left">用做左对齐</td></tr>
<tr><td style="text-align: left">+</td><td style="text-align: left">在正数前面显示加号( + )</td></tr>
<tr><td style="text-align: left"><sp></td><td style="text-align: left">在正数前面显示空格</td></tr>
<tr><td style="text-align: left">#</td><td style="text-align: left">在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')</td></tr>
<tr><td style="text-align: left">0</td><td style="text-align: left">显示的数字前面填充'0'而不是默认的空格</td></tr>
<tr><td style="text-align: left">%</td><td style="text-align: left">'%%'输出一个单一的'%'</td></tr>
<tr><td style="text-align: left">(var)</td><td style="text-align: left">映射变量(字典参数)</td></tr>
<tr><td style="text-align: left">m.n.</td><td style="text-align: left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr>
</tbody></table>
<p>Python2.6 开始，新增了一种格式化字符串的函数 <a href="https://www.runoob.com/python/att-string-format.html">str.format()</a>，它增强了字符串格式化的功能。</p>
<h2 id="python三引号"><a class="header" href="#python三引号">Python三引号</a></h2>
<p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下</p>
<pre><code class="language-python">#!/usr/bin/python3
 
para_str = &quot;&quot;&quot;这是一个多行字符串的实例
多行字符串可以使用制表符
TAB ( \t )。
也可以使用换行符 [ \n ]。
&quot;&quot;&quot;
print (para_str)
</code></pre>
<h2 id="f-string"><a class="header" href="#f-string">f-string</a></h2>
<pre><code class="language-python">&gt;&gt;&gt; name = 'Runoob'
&gt;&gt;&gt; 'Hello %s' % name
'Hello Runoob'
</code></pre>
<p><strong>f-string</strong> 格式化字符串以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'Runoob'
&gt;&gt;&gt; f'Hello {name}'  # 替换变量
'Hello Runoob'
&gt;&gt;&gt; f'{1+2}'         # 使用表达式
'3'

&gt;&gt;&gt; w = {'name': 'Runoob', 'url': 'www.runoob.com'}
&gt;&gt;&gt; f'{w[&quot;name&quot;]}: {w[&quot;url&quot;]}'
'Runoob: www.runoob.com'
</code></pre>
<p>用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。</p>
<p>在 Python 3.8 的版本中可以使用 <strong>=</strong> 符号来拼接运算表达式与结果：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 1
&gt;&gt;&gt; print(f'{x+1}')   # Python 3.6
2

&gt;&gt;&gt; x = 1
&gt;&gt;&gt; print(f'{x+1=}')   # Python 3.8
x+1=2
</code></pre>
<h2 id="unicode-字符串"><a class="header" href="#unicode-字符串">Unicode 字符串</a></h2>
<p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p>
<p>在Python3中，所有的字符串都是Unicode字符串。</p>
<h2 id="python-的字符串内建函数"><a class="header" href="#python-的字符串内建函数">Python 的字符串内建函数</a></h2>
<p>Python 的字符串常用内建函数如下：</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法及描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding='UTF-8',errors='strict')</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr>
<tr><td style="text-align: left">14</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr>
<tr><td style="text-align: left">15</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr>
<tr><td style="text-align: left">16</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr>
<tr><td style="text-align: left">17</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr>
<tr><td style="text-align: left">18</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr>
<tr><td style="text-align: left">19</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr>
<tr><td style="text-align: left">20</td><td style="text-align: left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr>
<tr><td style="text-align: left">21</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr>
<tr><td style="text-align: left">22</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr>
<tr><td style="text-align: left">23</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr>
<tr><td style="text-align: left">24</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr>
<tr><td style="text-align: left">25</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr>
<tr><td style="text-align: left">26</td><td style="text-align: left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr>
<tr><td style="text-align: left">27</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr>
<tr><td style="text-align: left">28</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))</a> 类似于 index()，不过是从右边开始.</td></tr>
<tr><td style="text-align: left">29</td><td style="text-align: left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr>
<tr><td style="text-align: left">30</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td></tr>
<tr><td style="text-align: left">31</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str=&quot;&quot;, num=string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr>
<tr><td style="text-align: left">32</td><td style="text-align: left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr>
<tr><td style="text-align: left">33</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr>
<tr><td style="text-align: left">34</td><td style="text-align: left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr>
<tr><td style="text-align: left">35</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr>
<tr><td style="text-align: left">36</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回&quot;标题化&quot;的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr>
<tr><td style="text-align: left">37</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=&quot;&quot;)</a> 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr>
<tr><td style="text-align: left">38</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr>
<tr><td style="text-align: left">39</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr>
<tr><td style="text-align: left">40</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-列表"><a class="header" href="#python3-列表">Python3 列表</a></h1>
<p>序列是 Python 中最基本的数据结构。</p>
<ul>
<li>
<p>Python 有 6 个序列的内置类型，但最常见的是列表和元组。</p>
</li>
<li>
<p>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</p>
</li>
<li>
<p>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
</li>
<li>
<p>列表的数据项不需要具有相同的类型</p>
</li>
<li>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p>
</li>
</ul>
<pre><code class="language-python">list1 = ['Google', 'Runoob', 1997, 2000]
list2 = [1, 2, 3, 4, 5 ]
list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
list4 = ['red', 'green', 'blue', 'yellow', 'white', 'black']
</code></pre>
<h2 id="更新列表"><a class="header" href="#更新列表">更新列表</a></h2>
<pre><code class="language-python">#!/usr/bin/python3
 
list = ['Google', 'Runoob', 1997, 2000]
 
print (&quot;第三个元素为 : &quot;, list[2])
list[2] = 2001
print (&quot;更新后的第三个元素为 : &quot;, list[2])
 
list1 = ['Google', 'Runoob', 'Taobao']
list1.append('Baidu')
print (&quot;更新后的列表 : &quot;, list1)
</code></pre>
<h2 id="删除列表元素"><a class="header" href="#删除列表元素">删除列表元素</a></h2>
<pre><code class="language-python">#!/usr/bin/python3
 
list = ['Google', 'Runoob', 1997, 2000]
 
print (&quot;原始列表 : &quot;, list)
del list[2]
print (&quot;删除第三个元素 : &quot;, list)
</code></pre>
<h2 id="python列表脚本操作符"><a class="header" href="#python列表脚本操作符">Python列表脚本操作符</a></h2>
<table><thead><tr><th style="text-align: left">Python 表达式</th><th style="text-align: left">结果</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">len([1, 2, 3])</td><td style="text-align: left">3</td><td style="text-align: left">长度</td></tr>
<tr><td style="text-align: left">[1, 2, 3] + [4, 5, 6]</td><td style="text-align: left">[1, 2, 3, 4, 5, 6]</td><td style="text-align: left">组合</td></tr>
<tr><td style="text-align: left">['Hi!'] * 4</td><td style="text-align: left">['Hi!', 'Hi!', 'Hi!', 'Hi!']</td><td style="text-align: left">重复</td></tr>
<tr><td style="text-align: left">3 in [1, 2, 3]</td><td style="text-align: left">True</td><td style="text-align: left">元素是否存在于列表中</td></tr>
<tr><td style="text-align: left">for x in [1, 2, 3]: print(x, end=&quot; &quot;)</td><td style="text-align: left">1 2 3</td><td style="text-align: left">迭代</td></tr>
</tbody></table>
<h2 id="python列表截取与拼接"><a class="header" href="#python列表截取与拼接">Python列表截取与拼接</a></h2>
<p>Python的列表截取与字符串操作类型，如下所示：</p>
<p>L=['Google', 'Runoob', 'Taobao']</p>
<table><thead><tr><th style="text-align: left">Python 表达式</th><th style="text-align: left">结果</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">L[2]</td><td style="text-align: left">'Taobao'</td><td style="text-align: left">读取第三个元素</td></tr>
<tr><td style="text-align: left">L[-2]</td><td style="text-align: left">'Runoob'</td><td style="text-align: left">从右侧开始读取倒数第二个元素: count from the right</td></tr>
<tr><td style="text-align: left">L[1:]</td><td style="text-align: left">['Runoob', 'Taobao']</td><td style="text-align: left">输出从第二个元素开始后的所有元素</td></tr>
</tbody></table>
<p>列表还支持拼接操作：</p>
<pre><code class="language-python">&gt;&gt;&gt;squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares += [36, 49, 64, 81, 100]
&gt;&gt;&gt; squares
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&gt;&gt;&gt;
</code></pre>
<h2 id="python列表函数方法"><a class="header" href="#python列表函数方法">Python列表函数&amp;方法</a></h2>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">函数</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr>
</tbody></table>
<p>Python包含以下方法:</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-元组"><a class="header" href="#python3-元组">Python3 元组</a></h1>
<p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号 <strong>( )</strong>，列表使用方括号 <strong>[ ]</strong>。</p>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<pre><code>&gt;&gt;&gt; tup1 = ('Google', 'Runoob', 1997, 2000)
&gt;&gt;&gt; tup2 = (1, 2, 3, 4, 5 )
&gt;&gt;&gt; tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;   #  不需要括号也可以
&gt;&gt;&gt; type(tup3)
&lt;class 'tuple'&gt;
</code></pre>
<p>元组中只包含一个元素时，需要在元素后面添加逗号 <strong>,</strong> ，否则括号会被当作运算符使用：</p>
<pre><code>## 实例(Python 3.0+)

\&gt;&gt;&gt; tup1 = (50)
\&gt;&gt;&gt; type(tup1)   # 不加逗号，类型为整型
&lt;**class** 'int'&gt;

\&gt;&gt;&gt; tup1 = (50,)
\&gt;&gt;&gt; type(tup1)   # 加上逗号，类型为元组
&lt;**class** 'tuple'&gt;
</code></pre>
<h2 id="访问元组"><a class="header" href="#访问元组">访问元组</a></h2>
<pre><code class="language-python">#!/usr/bin/python3
 
tup1 = ('Google', 'Runoob', 1997, 2000)
tup2 = (1, 2, 3, 4, 5, 6, 7 )
 
print (&quot;tup1[0]: &quot;, tup1[0])
print (&quot;tup2[1:5]: &quot;, tup2[1:5])

</code></pre>
<h2 id="修改元组"><a class="header" href="#修改元组">修改元组</a></h2>
<p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p>
<pre><code class="language-python">#!/usr/bin/python3
 
tup1 = (12, 34.56)
tup2 = ('abc', 'xyz')
 
# 以下修改元组元素操作是非法的。
# tup1[0] = 100
 
# 创建一个新的元组
tup3 = tup1 + tup2
print (tup3)
</code></pre>
<h2 id="删除元组"><a class="header" href="#删除元组">删除元组</a></h2>
<p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p>
<pre><code class="language-python">#!/usr/bin/python3
 
tup = ('Google', 'Runoob', 1997, 2000)
 
print (tup)
del tup
print (&quot;删除后的元组 tup : &quot;)
print (tup)
</code></pre>
<h2 id="元组运算符"><a class="header" href="#元组运算符">元组运算符</a></h2>
<p>与字符串一样，元组之间可以使用 <strong>+</strong> 号和 ***** 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table><thead><tr><th style="text-align: left">Python 表达式</th><th style="text-align: left">结果</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>len((1, 2, 3))</code></td><td style="text-align: left">3</td><td style="text-align: left">计算元素个数</td></tr>
<tr><td style="text-align: left"><code>(1, 2, 3) + (4, 5, 6)</code></td><td style="text-align: left">(1, 2, 3, 4, 5, 6)</td><td style="text-align: left">连接</td></tr>
<tr><td style="text-align: left"><code>('Hi!',) * 4</code></td><td style="text-align: left">('Hi!', 'Hi!', 'Hi!', 'Hi!')</td><td style="text-align: left">复制</td></tr>
<tr><td style="text-align: left"><code>3 in (1, 2, 3)</code></td><td style="text-align: left">True</td><td style="text-align: left">元素是否存在</td></tr>
<tr><td style="text-align: left"><code>for x in (1, 2, 3):     print (x, end=&quot; &quot;)</code></td><td style="text-align: left">1 2 3</td><td style="text-align: left">迭代</td></tr>
</tbody></table>
<hr />
<h2 id="元组索引截取"><a class="header" href="#元组索引截取">元组索引，截取</a></h2>
<pre><code>tup = ('Google', 'Runoob', 'Taobao', 'Wiki', 'Weibo','Weixin')
</code></pre>
<table><thead><tr><th style="text-align: left">Python 表达式</th><th style="text-align: left">结果</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">tup[1]</td><td style="text-align: left">'Runoob'</td><td style="text-align: left">读取第二个元素</td></tr>
<tr><td style="text-align: left">tup[-2]</td><td style="text-align: left">'Weibo'</td><td style="text-align: left">反向读取，读取倒数第二个元素</td></tr>
<tr><td style="text-align: left">tup[1:]</td><td style="text-align: left">('Runoob', 'Taobao', 'Wiki', 'Weibo', 'Weixin')</td><td style="text-align: left">截取元素，从第二个开始后的所有元素。</td></tr>
<tr><td style="text-align: left">tup[1:4]</td><td style="text-align: left">('Runoob', 'Taobao', 'Wiki')</td><td style="text-align: left">截取元素，从第二个开始到第四个元素（索引为 3）。</td></tr>
</tbody></table>
<h2 id="元组内置函数"><a class="header" href="#元组内置函数">元组内置函数</a></h2>
<p>Python元组包含了以下内置函数</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法及描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left">len(tuple) 计算元组元素个数。</td><td style="text-align: left"><code>&gt;&gt;&gt; tuple1 = ('Google', 'Runoob', 'Taobao') &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt; </code></td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">max(tuple) 返回元组中元素最大值。</td><td style="text-align: left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; max(tuple2) '8' &gt;&gt;&gt; </code></td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">min(tuple) 返回元组中元素最小值。</td><td style="text-align: left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; min(tuple2) '4' &gt;&gt;&gt; </code></td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">tuple(iterable) 将可迭代系列转换为元组。</td><td style="text-align: left"><code>&gt;&gt;&gt; list1= ['Google', 'Taobao', 'Runoob', 'Baidu'] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 ('Google', 'Taobao', 'Runoob', 'Baidu')</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-字典"><a class="header" href="#python3-字典">Python3 字典</a></h1>
<p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p>
<pre><code class="language-python">d = {key1 : value1, key2 : value2, key3 : value3 }

</code></pre>
<p>**注意：**<strong>dict</strong> 作为 Python 的关键字和内置函数，变量名不建议命名为 <strong>dict</strong>。</p>
<pre><code class="language-python">tinydict = {'name': 'runoob', 'likes': 123, 'url': 'www.runoob.com'}

tinydict1 = { 'abc': 456 }
tinydict2 = { 'abc': 123, 98.6: 37 }
</code></pre>
<h2 id="创建空字典"><a class="header" href="#创建空字典">创建空字典</a></h2>
<pre><code class="language-python"># 使用大括号 {} 来创建空字典
emptyDict = {}
 
# 打印字典
print(emptyDict)
 
# 查看字典的数量
print(&quot;Length:&quot;, len(emptyDict))
 
# 查看类型
print(type(emptyDict))
</code></pre>
<p>使用内建函数 <strong>dict()</strong> 创建字典：</p>
<pre><code class="language-python">emptyDict = dict()
 
# 打印字典
print(emptyDict)
 
# 查看字典的数量
print(&quot;Length:&quot;,len(emptyDict))
 
# 查看类型
print(type(emptyDict))
</code></pre>
<h2 id="访问字典里的值"><a class="header" href="#访问字典里的值">访问字典里的值</a></h2>
<pre><code class="language-python">#!/usr/bin/python3
 
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
 
print (&quot;tinydict['Name']: &quot;, tinydict['Name'])
print (&quot;tinydict['Age']: &quot;, tinydict['Age'])
</code></pre>
<p>如果用字典里没有的键访问数据，会输出错误如下：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
 
print (&quot;tinydict['Alice']: &quot;, tinydict['Alice'])
</code></pre>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 5, in &lt;module&gt;
    print (&quot;tinydict['Alice']: &quot;, tinydict['Alice'])
KeyError: 'Alice'
</code></pre>
<h2 id="修改字典"><a class="header" href="#修改字典">修改字典</a></h2>
<p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:</p>
<pre><code class="language-python">#!/usr/bin/python3
 
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
 
tinydict['Age'] = 8               # 更新 Age
tinydict['School'] = &quot;菜鸟教程&quot;  # 添加信息
 
 
print (&quot;tinydict['Age']: &quot;, tinydict['Age'])
print (&quot;tinydict['School']: &quot;, tinydict['School'])
</code></pre>
<h2 id="删除字典元素"><a class="header" href="#删除字典元素">删除字典元素</a></h2>
<p>能删单一的元素也能清空字典，清空只需一项操作。</p>
<p>显式删除一个字典用del命令，如下实例：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
 
del tinydict['Name'] # 删除键 'Name'
tinydict.clear()     # 清空字典
del tinydict         # 删除字典
 
print (&quot;tinydict['Age']: &quot;, tinydict['Age'])
print (&quot;tinydict['School']: &quot;, tinydict['School'])
</code></pre>
<h3 id="字典键的特性"><a class="header" href="#字典键的特性">字典键的特性</a></h3>
<p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p>
<p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p>
<h2 id="字典内置函数方法"><a class="header" href="#字典内置函数方法">字典内置函数&amp;方法</a></h2>
<p>Python字典包含了以下内置函数：</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">函数及描述</th><th style="text-align: left">实例</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left">len(dict) 计算字典元素个数，即键的总数。</td><td style="text-align: left"><code>&gt;&gt;&gt; tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} &gt;&gt;&gt; len(tinydict) 3</code></td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">str(dict) 输出字典，可以打印的字符串表示。</td><td style="text-align: left"><code>&gt;&gt;&gt; tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} &gt;&gt;&gt; str(tinydict) &quot;{'Name': 'Runoob', 'Class': 'First', 'Age': 7}&quot;</code></td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td style="text-align: left"><code>&gt;&gt;&gt; tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} &gt;&gt;&gt; type(tinydict) &lt;class 'dict'&gt;</code></td></tr>
</tbody></table>
<p>Python字典包含了以下内置方法：</p>
<p>Python字典包含了以下内置方法：</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">函数及描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default=None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left">[pop(key<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 随机返回并删除字典中的最后一对键和值。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-集合"><a class="header" href="#python3-集合">Python3 集合</a></h1>
<p>集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<pre><code class="language-python">parame = {value01,value02,...}
或者
set(value)
</code></pre>
<h2 id="集合的基本操作"><a class="header" href="#集合的基本操作">集合的基本操作</a></h2>
<h3 id="1添加元素"><a class="header" href="#1添加元素">1、添加元素</a></h3>
<pre><code class="language-python">s.add( x )

</code></pre>
<p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p>
<pre><code class="language-python">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))
&gt;&gt;&gt; thisset.add(&quot;Facebook&quot;)
&gt;&gt;&gt; print(thisset)
{'Taobao', 'Facebook', 'Google', 'Runoob'}
</code></pre>
<p>还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</p>
<pre><code>s.update( x )
</code></pre>
<p>x 可以有多个，用逗号分开。</p>
<pre><code class="language-python">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))
&gt;&gt;&gt; thisset.update({1,3})
&gt;&gt;&gt; print(thisset)
{1, 3, 'Google', 'Taobao', 'Runoob'}
&gt;&gt;&gt; thisset.update([1,4],[5,6])  
&gt;&gt;&gt; print(thisset)
{1, 3, 4, 5, 6, 'Google', 'Taobao', 'Runoob'}
&gt;&gt;&gt;
</code></pre>
<h3 id="2移除元素"><a class="header" href="#2移除元素">2、移除元素</a></h3>
<pre><code>s.remove( x )
</code></pre>
<p>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p>
<p>此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</p>
<pre><code>s.discard( x )
</code></pre>
<p>我们也可以设置随机删除集合中的一个元素，语法格式如下：</p>
<pre><code>s.pop() 
</code></pre>
<p>set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。</p>
<h3 id="3计算集合元素个数"><a class="header" href="#3计算集合元素个数">3、计算集合元素个数</a></h3>
<pre><code>len(s)	
</code></pre>
<h3 id="4清空集合"><a class="header" href="#4清空集合">4、清空集合</a></h3>
<pre><code>s.clear()

</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))
&gt;&gt;&gt; thisset.clear()
&gt;&gt;&gt; print(thisset)
set()
</code></pre>
<h3 id="5判断元素是否在集合中存在"><a class="header" href="#5判断元素是否在集合中存在">5、判断元素是否在集合中存在</a></h3>
<pre><code>x in s

</code></pre>
<h3 id="集合内置方法完整列表"><a class="header" href="#集合内置方法完整列表">集合内置方法完整列表</a></h3>
<table><thead><tr><th style="text-align: left">方法</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td><td style="text-align: left">为集合添加元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td><td style="text-align: left">移除集合中的所有元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td><td style="text-align: left">拷贝一个集合</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td><td style="text-align: left">返回多个集合的差集</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td><td style="text-align: left">移除集合中的元素，该元素在指定的集合也存在。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td><td style="text-align: left">删除集合中指定的元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td><td style="text-align: left">返回集合的交集</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td><td style="text-align: left">返回集合的交集。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td><td style="text-align: left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td><td style="text-align: left">判断指定集合是否为该方法参数集合的子集。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td><td style="text-align: left">判断该方法的参数集合是否为指定集合的子集</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td><td style="text-align: left">随机移除元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td><td style="text-align: left">移除指定元素</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td><td style="text-align: left">返回两个集合中不重复的元素集合。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td><td style="text-align: left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td><td style="text-align: left">返回两个集合的并集</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td><td style="text-align: left">给集合添加元素</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-数字number"><a class="header" href="#python3-数字number">Python3 数字(Number)</a></h1>
<p>Python 支持三种不同的数值类型：</p>
<ul>
<li><strong>整型(int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。</li>
<li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</li>
<li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<p>我们可以使用十六进制和八进制来代表整数：</p>
<pre><code>&gt;&gt;&gt; number = 0xA0F # 十六进制
&gt;&gt;&gt; number
2575

&gt;&gt;&gt; number=0o37 # 八进制
&gt;&gt;&gt; number
31
</code></pre>
<table><thead><tr><th style="text-align: left">int</th><th style="text-align: left">float</th><th style="text-align: left">complex</th></tr></thead><tbody>
<tr><td style="text-align: left">10</td><td style="text-align: left">0.0</td><td style="text-align: left">3.14j</td></tr>
<tr><td style="text-align: left">100</td><td style="text-align: left">15.20</td><td style="text-align: left">45.j</td></tr>
<tr><td style="text-align: left">-786</td><td style="text-align: left">-21.9</td><td style="text-align: left">9.322e-36j</td></tr>
<tr><td style="text-align: left">080</td><td style="text-align: left">32.3e+18</td><td style="text-align: left">.876j</td></tr>
<tr><td style="text-align: left">-0490</td><td style="text-align: left">-90.</td><td style="text-align: left">-.6545+0J</td></tr>
<tr><td style="text-align: left">-0x260</td><td style="text-align: left">-32.54e100</td><td style="text-align: left">3e+26J</td></tr>
<tr><td style="text-align: left">0x69</td><td style="text-align: left">70.2E-12</td><td style="text-align: left">4.53e-7j</td></tr>
</tbody></table>
<p>Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</p>
<h2 id="python-数字类型转换"><a class="header" href="#python-数字类型转换">Python 数字类型转换</a></h2>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<ul>
<li><strong>int(x)</strong> 将x转换为一个整数。</li>
<li><strong>float(x)</strong> 将x转换到一个浮点数。</li>
<li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li>
<li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li>
</ul>
<p>以下实例将浮点数变量 a 转换为整数：</p>
<pre><code>&gt;&gt;&gt; a = 1.0
&gt;&gt;&gt; int(a)
1
</code></pre>
<h2 id="python-数字运算"><a class="header" href="#python-数字运算">Python 数字运算</a></h2>
<p>Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。</p>
<p>表达式的语法很直白： <strong>+</strong>, <strong>-</strong>, ***** 和 <strong>/</strong>, 和其它语言（如Pascal或C）里一样。例如：</p>
<pre><code>&gt;&gt;&gt; 2 + 2
4
&gt;&gt;&gt; 50 - 5*6
20
&gt;&gt;&gt; (50 - 5*6) / 4
5.0
&gt;&gt;&gt; 8 / 5  # 总是返回一个浮点数
1.6
</code></pre>
<p>**注意：**在不同的机器上浮点运算的结果可能会不一样。</p>
<p>在整数除法中，除法 <strong>/</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>//</strong> ：</p>
<pre><code>&gt;&gt;&gt; 17 / 3  # 整数除法返回浮点型
5.666666666666667
&gt;&gt;&gt;
&gt;&gt;&gt; 17 // 3  # 整数除法返回向下取整后的结果
5
&gt;&gt;&gt; 17 % 3  # ％操作符返回除法的余数
2
&gt;&gt;&gt; 5 * 3 + 2 
17


</code></pre>
<p><strong>注意：****//</strong> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p>
<pre><code>&gt;&gt;&gt; 7//2
3
&gt;&gt;&gt; 7.0//2
3.0
&gt;&gt;&gt; 7//2.0
3.0
&gt;&gt;&gt; 
</code></pre>
<pre><code>&gt;&gt;&gt; width = 20
&gt;&gt;&gt; height = 5*9
&gt;&gt;&gt; width * height
900
</code></pre>
<p>Python 可以使用 *<strong>*</strong> 操作来进行幂运算：</p>
<pre><code>&gt;&gt;&gt; 5 ** 2  # 5 的平方
25
&gt;&gt;&gt; 2 ** 7  # 2的7次方
128

</code></pre>
<p>变量在使用前必须先&quot;定义&quot;（即赋予变量一个值），否则会出现错误：</p>
<p>不同类型的数混合运算时会将整数转换为浮点数：</p>
<pre><code>&gt;&gt;&gt; 3 * 3.75 / 1.5
7.5
&gt;&gt;&gt; 7.0 / 2
3.5

</code></pre>
<p>在交互模式中，最后被输出的表达式结果被赋值给变量 <strong>_</strong> 。例如：</p>
<pre><code>&gt;&gt;&gt; tax = 12.5 / 100
&gt;&gt;&gt; price = 100.50
&gt;&gt;&gt; price * tax
12.5625
&gt;&gt;&gt; price + _
113.0625
&gt;&gt;&gt; round(_, 2)
113.06

</code></pre>
<p>此处， <strong>_</strong> 变量应被用户视为只读变量。</p>
<h2 id="数学函数"><a class="header" href="#数学函数">数学函数</a></h2>
<table><thead><tr><th style="text-align: left">函数</th><th style="text-align: left">返回值 ( 描述 )</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td style="text-align: left">返回数字的绝对值，如abs(-10) 返回 10</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td style="text-align: left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr>
<tr><td style="text-align: left">cmp(x, y)</td><td style="text-align: left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td style="text-align: left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td style="text-align: left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td style="text-align: left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td style="text-align: left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td style="text-align: left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,...)</a></td><td style="text-align: left">返回给定参数的最大值，参数可以为序列。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,...)</a></td><td style="text-align: left">返回给定参数的最小值，参数可以为序列。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td style="text-align: left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td style="text-align: left">x**y 运算后的值。</td></tr>
<tr><td style="text-align: left">[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td><td style="text-align: left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td style="text-align: left">返回数字x的平方根。</td></tr>
</tbody></table>
<hr />
<h2 id="随机数函数"><a class="header" href="#随机数函数">随机数函数</a></h2>
<p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：</p>
<table><thead><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td><td style="text-align: left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr>
<tr><td style="text-align: left">[randrange (<a href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step])</a></td><td style="text-align: left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-random.html">random()</a></td><td style="text-align: left">随机生成下一个实数，它在[0,1)范围内。</td></tr>
<tr><td style="text-align: left">[seed(<a href="https://www.runoob.com/python3/python3-func-number-seed.html">x])</a></td><td style="text-align: left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst)</a></td><td style="text-align: left">将序列的所有元素随机排序</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td><td style="text-align: left">随机生成下一个实数，它在[x,y]范围内。</td></tr>
</tbody></table>
<hr />
<h2 id="三角函数"><a class="header" href="#三角函数">三角函数</a></h2>
<p>Python包括以下三角函数：</p>
<table><thead><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td><td style="text-align: left">返回x的反余弦弧度值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td><td style="text-align: left">返回x的反正弦弧度值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td><td style="text-align: left">返回x的反正切弧度值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td><td style="text-align: left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td><td style="text-align: left">返回x的弧度的余弦值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td><td style="text-align: left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td><td style="text-align: left">返回的x弧度的正弦值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td><td style="text-align: left">返回x弧度的正切值。</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td><td style="text-align: left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr>
<tr><td style="text-align: left"><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td><td style="text-align: left">将角度转换为弧度</td></tr>
</tbody></table>
<hr />
<h2 id="数学常量"><a class="header" href="#数学常量">数学常量</a></h2>
<table><thead><tr><th style="text-align: left">常量</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">pi</td><td style="text-align: left">数学常量 pi（圆周率，一般以π来表示）</td></tr>
<tr><td style="text-align: left">e</td><td style="text-align: left">数学常量 e，e即自然常数（自然常数）。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-条件控制"><a class="header" href="#python3-条件控制">Python3 条件控制</a></h1>
<p>Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。</p>
<pre><code class="language-python">if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
</code></pre>
<pre><code class="language-python">if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else:
        语句
elif 表达式4:
    语句
else:
    语句
</code></pre>
<h1 id="python3-循环语句"><a class="header" href="#python3-循环语句">Python3 循环语句</a></h1>
<h2 id="while-循环"><a class="header" href="#while-循环">while 循环</a></h2>
<pre><code class="language-python">while 判断条件(condition)：
    执行语句(statements)……
</code></pre>
<h3 id="无限循环"><a class="header" href="#无限循环">无限循环</a></h3>
<pre><code class="language-python">#!/usr/bin/python3
 
var = 1
while var == 1 :  # 表达式永远为 true
   num = int(input(&quot;输入一个数字  :&quot;))
   print (&quot;你输入的数字是: &quot;, num)
 
print (&quot;Good bye!&quot;)
</code></pre>
<h3 id="while-循环使用-else-语句"><a class="header" href="#while-循环使用-else-语句">while 循环使用 else 语句</a></h3>
<p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p>
<p>语法格式如下：</p>
<pre><code class="language-python">while &lt;expr&gt;:
    &lt;statement(s)&gt;
else:
    &lt;additional_statement(s)&gt;
</code></pre>
<pre><code class="language-python">#!/usr/bin/python3
 
count = 0
while count &lt; 5:
   print (count, &quot; 小于 5&quot;)
   count = count + 1
else:
   print (count, &quot; 大于或等于 5&quot;)
</code></pre>
<pre><code class="language-python">#!/usr/bin/python
 
flag = 1
 
while (flag): print ('欢迎访问菜鸟教程!')
 
print (&quot;Good bye!&quot;)
</code></pre>
<h2 id="for-语句"><a class="header" href="#for-语句">for 语句</a></h2>
<pre><code class="language-python">for &lt;variable&gt; in &lt;sequence&gt;:
    &lt;statements&gt;
else:
    &lt;statements&gt;
</code></pre>
<h2 id="range函数"><a class="header" href="#range函数">range()函数</a></h2>
<p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p>
<pre><code>&gt;&gt;&gt;for i in range(5):
...     print(i)
...
0
1
2
3
4
</code></pre>
<p>你也可以使用range指定区间的值：</p>
<pre><code>&gt;&gt;&gt;for i in range(5,9) :
    print(i)
 
    
5
6
7
8
&gt;&gt;&gt;
</code></pre>
<p>也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'步长'):</p>
<pre><code>&gt;&gt;&gt;for i in range(0, 10, 3) :
    print(i)
 
    
0
3
6
9
&gt;&gt;&gt;
</code></pre>
<h2 id="pass-语句"><a class="header" href="#pass-语句">pass 语句</a></h2>
<p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-迭代器与生成器"><a class="header" href="#python3-迭代器与生成器">Python3 迭代器与生成器</a></h1>
<h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<ul>
<li>
<p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
</li>
<li>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
</li>
<li>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
</li>
<li>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>
</li>
<li>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<pre><code class="language-python">&gt;&gt;&gt; list=[1,2,3,4]
&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象
&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素
1
&gt;&gt;&gt; print (next(it))
2
&gt;&gt;&gt;
</code></pre>
</li>
</ul>
<p>迭代器对象可以使用常规for语句进行遍历：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=&quot; &quot;)
</code></pre>
<p>也可以使用 next() 函数：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
import sys         # 引入 sys 模块
 
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
 
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
</code></pre>
<h3 id="创建一个迭代器"><a class="header" href="#创建一个迭代器">创建一个迭代器</a></h3>
<ul>
<li>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</li>
<li>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</li>
<li><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</li>
<li><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</li>
</ul>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
</code></pre>
<h3 id="stopiteration"><a class="header" href="#stopiteration">StopIteration</a></h3>
<p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p>
<pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x)
</code></pre>
<h2 id="生成器"><a class="header" href="#生成器">生成器</a></h2>
<ul>
<li>
<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
</li>
<li>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
</li>
<li>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
</li>
<li>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
</li>
</ul>
<pre><code class="language-python">#!/usr/bin/python3
 
import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter &gt; n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
 
while True:
    try:
        print (next(f), end=&quot; &quot;)
    except StopIteration:
        sys.exit()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-函数"><a class="header" href="#python3-函数">Python3 函数</a></h1>
<p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。</p>
<p>你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<h2 id="定义一个函数"><a class="header" href="#定义一个函数">定义一个函数</a></h2>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li>
</ul>
<p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<pre><code>def 函数名（参数列表）:
    函数体
</code></pre>
<p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p>
<h2 id="函数调用"><a class="header" href="#函数调用">函数调用</a></h2>
<p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p>
<p>如下实例调用了 <strong>printme()</strong> 函数：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
# 定义函数
def printme( str ):
   # 打印任何传入的字符串
   print (str)
   return
 
# 调用函数
printme(&quot;我要调用用户自定义函数!&quot;)
printme(&quot;再次调用同一函数&quot;)
</code></pre>
<h2 id="参数传递"><a class="header" href="#参数传递">参数传递</a></h2>
<p>在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：</p>
<pre><code>a=[1,2,3]

a=&quot;Runoob&quot;
</code></pre>
<p>以上代码中，<strong>[1,2,3]</strong> 是 List 类型，<strong>&quot;Runoob&quot;</strong> 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<h3 id="可更改mutable与不可更改immutable对象"><a class="header" href="#可更改mutable与不可更改immutable对象">可更改(mutable)与不可更改(immutable)对象</a></h3>
<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li>**不可变类型：**变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li>
<li>**可变类型：**变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li>**不可变类型：**类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li>
<li>**可变类型：**类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li>
</ul>
<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<h3 id="python-传不可变对象实例"><a class="header" href="#python-传不可变对象实例">python 传不可变对象实例</a></h3>
<pre><code class="language-python">//通过 id() 函数来查看内存地址变化：

def change(a):
    print(id(a))   # 指向的是同一个对象
    a=10
    print(id(a))   # 一个新对象
 
a=1
print(id(a))
change(a)

</code></pre>
<p>以上实例输出结果为：</p>
<pre><code>4379369136
4379369136
4379369424
</code></pre>
<p>可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。</p>
<h3 id="传可变对象实例"><a class="header" href="#传可变对象实例">传可变对象实例</a></h3>
<p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
# 可写函数说明
def changeme( mylist ):
   &quot;修改传入的列表&quot;
   mylist.append([1,2,3,4])
   print (&quot;函数内取值: &quot;, mylist)
   return
 
# 调用changeme函数
mylist = [10,20,30]
changeme( mylist )
print (&quot;函数外取值: &quot;, mylist)
</code></pre>
<h2 id="参数"><a class="header" href="#参数">参数</a></h2>
<p>以下是调用函数时可使用的正式参数类型：</p>
<ul>
<li>必需参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<h3 id="必需参数"><a class="header" href="#必需参数">必需参数</a></h3>
<p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：</p>
<h3 id="关键字参数"><a class="header" href="#关键字参数">关键字参数</a></h3>
<p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<pre><code class="language-PYTHON">#!/usr/bin/python3
 
#可写函数说明
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str)
   return
 
#调用printme函数
printme( str = &quot;菜鸟教程&quot;)

</code></pre>
<p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<pre><code class="language-python"> 
#可写函数说明
def printinfo( name, age ):
   &quot;打印任何传入的字符串&quot;
   print (&quot;名字: &quot;, name)
   print (&quot;年龄: &quot;, age)
   return
 
#调用printinfo函数
printinfo( age=50, name=&quot;runoob&quot; )
</code></pre>
<h3 id="默认参数"><a class="header" href="#默认参数">默认参数</a></h3>
<p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
#可写函数说明
def printinfo( name, age = 35 ):
   &quot;打印任何传入的字符串&quot;
   print (&quot;名字: &quot;, name)
   print (&quot;年龄: &quot;, age)
   return
 
#调用printinfo函数
printinfo( age=50, name=&quot;runoob&quot; )
print (&quot;------------------------&quot;)
printinfo( name=&quot;runoob&quot; )
</code></pre>
<h3 id="不定长参数"><a class="header" href="#不定长参数">不定长参数</a></h3>
<p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p>
<pre><code class="language-python">def functionname([formal_args,] *var_args_tuple ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre>
<p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p>
<pre><code class="language-python">#!/usr/bin/python3
  
# 可写函数说明
def printinfo( arg1, *vartuple ):
   &quot;打印任何传入的参数&quot;
   print (&quot;输出: &quot;)
   print (arg1)
   print (vartuple)
 
# 调用printinfo 函数
printinfo( 70, 60, 50 )
</code></pre>
<pre><code>输出: 
70
(60, 50)
</code></pre>
<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<pre><code>#!/usr/bin/python3
 
# 可写函数说明
def printinfo( arg1, *vartuple ):
   &quot;打印任何传入的参数&quot;
   print (&quot;输出: &quot;)
   print (arg1)
   for var in vartuple:
      print (var)
   return
 
# 调用printinfo 函数
printinfo( 10 )
printinfo( 70, 60, 50 )
</code></pre>
<p>还有一种就是参数带两个星号 ******基本语法如下：</p>
<pre><code class="language-python">def functionname([formal_args,] **var_args_dict ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre>
<p>加了两个星号 *<strong>*</strong> 的参数会以字典的形式导入。</p>
<pre><code class="language-python">#!/usr/bin/python3
  
# 可写函数说明
def printinfo( arg1, **vardict ):
   &quot;打印任何传入的参数&quot;
   print (&quot;输出: &quot;)
   print (arg1)
   print (vardict)
 
# 调用printinfo 函数
printinfo(1, a=2,b=3)
</code></pre>
<p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p>
<pre><code class="language-python">def f(a,b,*,c):
    return a+b+c
</code></pre>
<p><strong>如果单独出现星号 * 后的参数必须用关键字传入。</strong></p>
<pre><code>&gt;&gt;&gt; def f(a,b,*,c):
...     return a+b+c
... 
&gt;&gt;&gt; f(1,2,3)   # 报错
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: f() takes 2 positional arguments but 3 were given
&gt;&gt;&gt; f(1,2,c=3) # 正常
6
&gt;&gt;&gt;
</code></pre>
<h2 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h2>
<p>Python 使用 <strong>lambda</strong> 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数。</p>
<ul>
<li><strong>lambda</strong> 只是一个表达式，函数体比 <strong>def</strong> 简单很多。</li>
<li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li>
<li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<p>lambda 函数的语法只包含一个语句，如下：</p>
<pre><code>lambda [arg1 [,arg2,.....argn]]:expression
</code></pre>
<p>设置参数 a 加上 10:</p>
<pre><code>x = lambda a : a + 10 print(x(5))
</code></pre>
<p>以下实例匿名函数设置两个参数：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2
 
# 调用sum函数
print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))
print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))
</code></pre>
<p>我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p>
<p>以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：</p>
<pre><code class="language-python">def myfunc(n):
  return lambda a : a * n
 
mydoubler = myfunc(2)
mytripler = myfunc(3)
 
print(mydoubler(11))
print(mytripler(11))
</code></pre>
<h2 id="return语句"><a class="header" href="#return语句">return语句</a></h2>
<p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
# 可写函数说明
def sum( arg1, arg2 ):
   # 返回2个参数的和.&quot;
   total = arg1 + arg2
   print (&quot;函数内 : &quot;, total)
   return total
 
# 调用sum函数
total = sum( 10, 20 )
print (&quot;函数外 : &quot;, total)
</code></pre>
<pre><code>函数内 :  30
函数外 :  30
</code></pre>
<h2 id="强制位置参数"><a class="header" href="#强制位置参数">强制位置参数</a></h2>
<p>Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p>
<pre><code class="language-python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>
<pre><code>f(10, 20, 30, d=40, e=50, f=60)
</code></pre>
<p>以下使用方法会发生错误:</p>
<pre><code>f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-json-数据解析"><a class="header" href="#python3-json-数据解析">Python3 JSON 数据解析</a></h1>
<p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。</p>
<p>Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数：</p>
<ul>
<li><strong>json.dumps():</strong> 对数据进行编码。</li>
<li><strong>json.loads():</strong> 对数据进行解码。</li>
</ul>
<p>在 json 的编解码过程中，Python 的原始类型与 json 类型会相互转换，具体的转化对照如下：</p>
<h3 id="python-编码为-json-类型转换对应表"><a class="header" href="#python-编码为-json-类型转换对应表">Python 编码为 JSON 类型转换对应表：</a></h3>
<table><thead><tr><th style="text-align: left">Python</th><th style="text-align: left">JSON</th></tr></thead><tbody>
<tr><td style="text-align: left">dict</td><td style="text-align: left">object</td></tr>
<tr><td style="text-align: left">list, tuple</td><td style="text-align: left">array</td></tr>
<tr><td style="text-align: left">str</td><td style="text-align: left">string</td></tr>
<tr><td style="text-align: left">int, float, int- &amp; float-derived Enums</td><td style="text-align: left">number</td></tr>
<tr><td style="text-align: left">True</td><td style="text-align: left">true</td></tr>
<tr><td style="text-align: left">False</td><td style="text-align: left">false</td></tr>
<tr><td style="text-align: left">None</td><td style="text-align: left">null</td></tr>
</tbody></table>
<h3 id="json-解码为-python-类型转换对应表"><a class="header" href="#json-解码为-python-类型转换对应表">JSON 解码为 Python 类型转换对应表：</a></h3>
<table><thead><tr><th style="text-align: left">JSON</th><th style="text-align: left">Python</th></tr></thead><tbody>
<tr><td style="text-align: left">object</td><td style="text-align: left">dict</td></tr>
<tr><td style="text-align: left">array</td><td style="text-align: left">list</td></tr>
<tr><td style="text-align: left">string</td><td style="text-align: left">str</td></tr>
<tr><td style="text-align: left">number (int)</td><td style="text-align: left">int</td></tr>
<tr><td style="text-align: left">number (real)</td><td style="text-align: left">float</td></tr>
<tr><td style="text-align: left">true</td><td style="text-align: left">True</td></tr>
<tr><td style="text-align: left">false</td><td style="text-align: left">False</td></tr>
<tr><td style="text-align: left">null</td><td style="text-align: left">None</td></tr>
</tbody></table>
<h3 id="jsondumps-与-jsonloads-实例以下实例演示了-python-数据结构转换为json"><a class="header" href="#jsondumps-与-jsonloads-实例以下实例演示了-python-数据结构转换为json">json.dumps 与 json.loads 实例以下实例演示了 Python 数据结构转换为JSON：</a></h3>
<pre><code class="language-python">#!/usr/bin/python3
 
import json
 
# Python 字典类型转换为 JSON 对象
data = {
    'no' : 1,
    'name' : 'Runoob',
    'url' : 'http://www.runoob.com'
}
 
json_str = json.dumps(data)
print (&quot;Python 原始数据：&quot;, repr(data))
print (&quot;JSON 对象：&quot;, json_str)
</code></pre>
<pre><code>Python 原始数据： {'url': 'http://www.runoob.com', 'no': 1, 'name': 'Runoob'}
JSON 对象： {&quot;url&quot;: &quot;http://www.runoob.com&quot;, &quot;no&quot;: 1, &quot;name&quot;: &quot;Runoob&quot;}
</code></pre>
<p>通过输出的结果可以看出，简单类型通过编码后跟其原始的repr()输出结果非常相似。</p>
<p>接着以上实例，我们可以将一个JSON编码的字符串转换回一个Python数据结构：</p>
<pre><code class="language-python">#!/usr/bin/python3
 
import json
 
# Python 字典类型转换为 JSON 对象
data1 = {
    'no' : 1,
    'name' : 'Runoob',
    'url' : 'http://www.runoob.com'
}
 
json_str = json.dumps(data1)
print (&quot;Python 原始数据：&quot;, repr(data1))
print (&quot;JSON 对象：&quot;, json_str)
 
# 将 JSON 对象转换为 Python 字典
data2 = json.loads(json_str)
print (&quot;data2['name']: &quot;, data2['name'])
print (&quot;data2['url']: &quot;, data2['url'])
</code></pre>
<p>如果你要处理的是文件而不是字符串，你可以使用 <strong>json.dump()</strong> 和 <strong>json.load()</strong> 来编码和解码JSON数据。例如：</p>
<pre><code class="language-python"># 写入 JSON 数据
with open('data.json', 'w') as f:
    json.dump(data, f)
 
# 读取数据
with open('data.json', 'r') as f:
    data = json.load(f)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-面向对象"><a class="header" href="#python3-面向对象">Python3 面向对象</a></h1>
<p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</p>
<p>接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<hr />
<h2 id="面向对象技术简介"><a class="header" href="#面向对象技术简介">面向对象技术简介</a></h2>
<ul>
<li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li>**方法：**类中定义的函数。</li>
<li>**类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li>**数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li>**局部变量：**定义在方法中的变量，只作用于当前实例的类。</li>
<li>**实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li>
<li>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</li>
<li>**实例化：**创建一个类的实例，类的具体对象。</li>
<li>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p>
<p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>对象可以包含任意数量和类型的数据。</p>
<h2 id="类定义"><a class="header" href="#类定义">类定义</a></h2>
<p>语法格式如下：</p>
<pre><code>class ClassName:    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;
</code></pre>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<h2 id="创建类"><a class="header" href="#创建类">创建类</a></h2>
<p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p>
<pre><code class="language-python">class ClassName:
   '类的帮助信息'   #类文档字符串
   class_suite  #类体
  
  
 // 类的帮助信息可以通过ClassName.__doc__查看。
 // class_suite 由类成员，方法，数据属性组成。
</code></pre>
<h2 id="python内置类属性"><a class="header" href="#python内置类属性">Python内置类属性</a></h2>
<ul>
<li><code>__dict__ </code>: 类的属性（包含一个字典，由类的数据属性组成）</li>
<li><code>__doc__</code> :类的文档字符串</li>
<li><code>__name__</code>: 类名</li>
<li><code>__module__</code>: 类定义所在的模块（类的全名是'<strong>main</strong>.className'，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）</li>
<li><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li>
</ul>
<h2 id="类对象"><a class="header" href="#类对象">类对象</a></h2>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class MyClass:    
  &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;    
  i = 12345    
  def f(self): return 'hello world'  
# 实例化类 
x = MyClass()  
# 访问类的属性和方法 
print(&quot;MyClass 类的属性 i 为：&quot;, x.i) 
print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())
</code></pre>
<p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<pre><code>MyClass 类的属性 i 为： 12345
MyClass 类的方法 f 输出为： hello world
</code></pre>
<hr />
<p>类有一个名为 <strong>init</strong>() 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，像下面这样：</p>
<pre><code>def __init__(self):    self.data = []
</code></pre>
<p>类定义了 <strong>init</strong>() 方法，类的实例化操作会自动调用 <strong>init</strong>() 方法。如下实例化类 MyClass，对应的 <strong>init</strong>() 方法就会被调用:</p>
<pre><code>x = MyClass()
</code></pre>
<p>当然， <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。例如:</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class Complex:    
	def __init__(self, realpart, imagpart):        
		self.r = realpart        
		self.i = imagpart 

x = Complex(3.0, -4.5) 
print(x.r, x.i)   
# 输出结果：3.0 -4.5
</code></pre>
<h3 id="self代表类的实例而非类"><a class="header" href="#self代表类的实例而非类">self代表类的实例，而非类</a></h3>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p>
<pre><code class="language-python">class Test:    
	def prt(self):        
		print(self)        
		print(self.__class__)  
		
t = Test() 
t.prt()
</code></pre>
<p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre>
<p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p>
<p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p>
<pre><code class="language-python">class Test:    
	def prt(runoob):        
	print(runoob)        
	print(runoob.__class__)  

t = Test() 
t.prt()
</code></pre>
<p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre>
<hr />
<h2 id="类的方法"><a class="header" href="#类的方法">类的方法</a></h2>
<p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
#类定义 
class people:    
#定义基本属性   
	name = ''    
  age = 0    
#定义私有属性,私有属性在类外部无法直接进行访问    
__weight = 0    
#定义构造方法    
def __init__(self,n,a,w):        
  self.name = n        
  self.age = a        
  self.__weight = w    
  
def speak(self):        
  print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))  
 # 实例化类 
p = people('runoob',10,30) 
p.speak()
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>runoob 说: 我 10 岁。
</code></pre>
<hr />
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p>
<pre><code>class DerivedClassName(BaseClassName):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;
</code></pre>
<p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p>
<p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<pre><code>class DerivedClassName(modname.BaseClassName):
</code></pre>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
#类定义 
class people:    
#定义基本属性    
	name = ''    
	age = 0    
#定义私有属性,私有属性在类外部无法直接进行访问    
	__weight = 0    
#定义构造方法    
def __init__(self,n,a,w):        
	self.name = n        
  self.age = a        
  self.__weight = w    
def speak(self):        
  print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))  
#单继承示例 
class student(people):    
  grade = ''    
  def __init__(self,n,a,w,g):        
#调用父类的构函        
	people.__init__(self,n,a,w)        
  self.grade = g    
#覆写父类的方法    
	def speak(self):        
  print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))    
  
s = student('ken',10,60,3) 
s.speak()
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>ken 说: 我 10 岁了，我在读 3 年级
</code></pre>
<hr />
<h2 id="多继承"><a class="header" href="#多继承">多继承</a></h2>
<p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<pre><code>class DerivedClassName(Base1, Base2, Base3):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;
</code></pre>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，<strong>从左到右查找父类中是否包含方法。</strong></p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
#类定义 
class people:    
#定义基本属性    
name = ''    age = 0   
#定义私有属性,私有属性在类外部无法直接进行访问   
__weight = 0    
#定义构造方法    
def __init__(self,n,a,w):        
  self.name = n        
  self.age = a        
  self.__weight = w    
def speak(self):        
  print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))  
#单继承示例 
class student(people):    
  grade = ''    
  def __init__(self,n,a,w,g):        
    #调用父类的构函        
    people.__init__(self,n,a,w)        
    self.grade = g    
#覆写父类的方法    
	def speak(self):        
    print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))  
#另一个类，多重继承之前的准备 
class speaker():    
  topic = ''    
  name = ''    
  def __init__(self,n,t):        
    self.name = n        
    self.topic = t    
def speak(self):        
  print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))  
#多重继承 
class sample(speaker,student):    
	a =''    def __init__(self,n,a,w,g,t):        
	student.__init__(self,n,a,w,g)        
  speaker.__init__(self,n,t)  
  
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;) 
test.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<hr />
<h2 id="方法重写"><a class="header" href="#方法重写">方法重写</a></h2>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class Parent:        
  # 定义父类   
  def myMethod(self):      
    print ('调用父类方法')  
class Child(Parent): 
  # 定义子类   
  def myMethod(self):      
    print ('调用子类方法')  
    
c = Child()          
# 子类实例 
c.myMethod()         
# 子类调用重写方法 
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
</code></pre>
<p><a href="https://www.runoob.com/python/python-func-super.html">super() 函数</a>是用于调用父类(超类)的一个方法。</p>
<p>执行以上程序输出结果为：</p>
<pre><code>调用子类方法
调用父类方法
</code></pre>
<p><strong>更多文档：</strong></p>
<p><a href="https://www.runoob.com/w3cnote/python-extends-init.html">Python 子类继承父类构造函数说明</a></p>
<hr />
<h2 id="类属性与方法"><a class="header" href="#类属性与方法">类属性与方法</a></h2>
<h3 id="类的私有属性"><a class="header" href="#类的私有属性">类的私有属性</a></h3>
<p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p>
<h3 id="类的方法-1"><a class="header" href="#类的方法-1">类的方法</a></h3>
<p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p>
<p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p>
<h3 id="类的私有方法"><a class="header" href="#类的私有方法">类的私有方法</a></h3>
<p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p>
<h3 id="实例-3"><a class="header" href="#实例-3">实例</a></h3>
<p>类的私有属性实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3 
class JustCounter:    
  __secretCount = 0  
# 私有变量    
	publicCount = 0    
# 公开变量     
	def count(self):       
    self.__secretCount += 1        
    self.publicCount += 1        
    print (self.__secretCount)  
counter = JustCounter() 
counter.count() 
counter.count() 
print (counter.publicCount) 
print (counter.__secretCount)  # 报错，实例不能访问私有变量
</code></pre>
<p>执行以上程序输出结果为：</p>
<pre><code>1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: 'JustCounter' object has no attribute '__secretCount'
</code></pre>
<p>类的私有方法实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3
 
class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private
 
    def who(self):
        print('name  : ', self.name)
        print('url : ', self.__url)
 
    def __foo(self):          # 私有方法
        print('这是私有方法')
 
    def foo(self):            # 公共方法
        print('这是公共方法')
        self.__foo()
 
x = Site('菜鸟教程', 'www.runoob.com')
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
</code></pre>
<h3 id="类的专有方法"><a class="header" href="#类的专有方法">类的专有方法：</a></h3>
<ul>
<li><strong><strong>init</strong> :</strong> 构造函数，在生成对象时调用</li>
<li><strong><strong>del</strong> :</strong> 析构函数，释放对象时使用</li>
<li><strong><strong>repr</strong> :</strong> 打印，转换</li>
<li><strong><strong>setitem</strong> :</strong> 按照索引赋值</li>
<li><strong><strong>getitem</strong>:</strong> 按照索引获取值</li>
<li><strong><strong>len</strong>:</strong> 获得长度</li>
<li><strong><strong>cmp</strong>:</strong> 比较运算</li>
<li><strong><strong>call</strong>:</strong> 函数调用</li>
<li><strong><strong>add</strong>:</strong> 加运算</li>
<li><strong><strong>sub</strong>:</strong> 减运算</li>
<li><strong><strong>mul</strong>:</strong> 乘运算</li>
<li><strong><strong>truediv</strong>:</strong> 除运算</li>
<li><strong><strong>mod</strong>:</strong> 求余运算</li>
<li><strong><strong>pow</strong>:</strong> 乘方</li>
</ul>
<h3 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h3>
<p>Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：</p>
<p><strong>实例(Python 3.0+)</strong></p>
<pre><code class="language-python">#!/usr/bin/python3  
class Vector:   
  def __init__(self, a, b):      
    self.a = a      
    self.b = b    
  def __str__(self):      
    return 'Vector (%d, %d)' % (self.a, self.b)      
  def __add__(self,other):      
    return Vector(self.a + other.a, self.b + other.b)  

  v1 = Vector(2,10) 
  v2 = Vector(5,-2) 
  print (v1 + v2)
</code></pre>
<p>以上代码执行结果如下所示:</p>
<pre><code>Vector(7,8)
</code></pre>
<h2 id="单下划线双下划线头尾双下划线说明"><a class="header" href="#单下划线双下划线头尾双下划线说明">单下划线、双下划线、头尾双下划线说明：</a></h2>
<ul>
<li><strong><strong>foo</strong></strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong><strong>init</strong>()</strong> 之类的。</li>
<li><strong>_foo</strong>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li>
<li><strong>__foo</strong>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li>
</ul>
<h2 id="python对象销毁垃圾回收"><a class="header" href="#python对象销毁垃圾回收">python对象销毁(垃圾回收)</a></h2>
<p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。</p>
<p>在 Python 内部记录着所有使用中的对象各有多少引用。</p>
<p>一个内部跟踪变量，称为一个引用计数器。</p>
<p>当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p>
<pre><code class="language-python">a = 40      # 创建对象  &lt;40&gt;
b = a       # 增加引用， &lt;40&gt; 的计数
c = [b]     # 增加引用.  &lt;40&gt; 的计数

del a       # 减少引用 &lt;40&gt; 的计数
b = 100     # 减少引用 &lt;40&gt; 的计数
c[0] = -1   # 减少引用 &lt;40&gt; 的计数

</code></pre>
<p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p>
<h2 id="基础重载方法"><a class="header" href="#基础重载方法">基础重载方法</a></h2>
<p>下表列出了一些通用的功能，你可以在自己的类重写：</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法, 描述 &amp; 简单的调用</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong><strong>init</strong> ( self [,args...] )</strong> 构造函数 简单的调用方法: <em>obj = className(args)</em></td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong><strong>del</strong>( self )</strong> 析构方法, 删除一个对象 简单的调用方法 : <em>del obj</em></td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong><strong>repr</strong>( self )</strong> 转化为供解释器读取的形式 简单的调用方法 : <em>repr(obj)</em></td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong><strong>str</strong>( self )</strong> 用于将值转化为适于人阅读的形式 简单的调用方法 : <em>str(obj)</em></td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong><strong>cmp</strong> ( self, x )</strong> 对象比较 简单的调用方法 : <em>cmp(obj, x)</em></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="构建一个模块的层级包"><a class="header" href="#构建一个模块的层级包">构建一个模块的层级包</a></h2>
<p>封装成包是很简单的。在文件系统上组织你的代码，并确保每个目录都定义了一个__init__.py文件。 例如：</p>
<pre><code class="language-python">graphics/
    __init__.py
    primitive/
        __init__.py
        line.py
        fill.py
        text.py
    formats/
        __init__.py
        png.py
        jpg.py
</code></pre>
<p>一旦你做到了这一点，你应该能够执行各种import语句，如下：</p>
<pre><code class="language-python">import graphics.primitive.line
from graphics.primitive import line
import graphics.formats.jpg as jpg
</code></pre>
<h3 id="讨论"><a class="header" href="#讨论">讨论</a></h3>
<ol>
<li>定义模块的层次结构就像在文件系统上建立目录结构一样容易。 </li>
<li>文件__init__.py的目的是要包含不同运行级别的包的可选的初始化代码。</li>
<li>举个例子，如果你执行了语句import graphics， 文件graphics/<strong>init</strong>.py将被导入,建立graphics命名空间的内容。</li>
<li>像import graphics.format.jpg这样导入，文件graphics/<strong>init</strong>.py和文件graphics/formats/<strong>init</strong>.py将在文件graphics/formats/jpg.py导入之前导入。</li>
</ol>
<p>绝大部分时候让__init__.py空着就好。但是有些情况下可能包含代码。 举个例子，<strong>init</strong>.py能够用来自动加载子模块:</p>
<pre><code># graphics/formats/__init__.py
from . import jpg
from . import png
</code></pre>
<ul>
<li>
<p><strong>像这样一个文件,用户可以仅仅通过import grahpics.formats来代替import graphics.formats.jpg以及import graphics.formats.png。</strong></p>
</li>
<li>
<p><strong>init.py的其他常用用法包括将多个文件合并到一个逻辑命名空间，</strong></p>
</li>
</ul>
<p>敏锐的程序员会发现，即使没有__init__.py文件存在，python仍然会导入包。<strong>如果你没有定义init.py时，实际上创建了一个所谓的“命名空间包”</strong>，</p>
<h2 id="控制模块被全部导入的内容"><a class="header" href="#控制模块被全部导入的内容">控制模块被全部导入的内容</a></h2>
<h3 id="问题"><a class="header" href="#问题">问题</a></h3>
<p>当使用from module import <a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p02_control_the_import_of_everything.html#id3">*</a>   语句时，希望对从模块或包导出的符号进行精确控制。</p>
<h3 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h3>
<p>在你的模块中定义一个变量 <strong>all</strong> 来明确地列出需要导出的内容。</p>
<p>举个例子:</p>
<pre><code># somemodule.py
def spam():
    pass

def grok():
    pass

blah = 42
# Only export 'spam' and 'grok'
__all__ = ['spam', 'grok']
</code></pre>
<h3 id="讨论-1"><a class="header" href="#讨论-1">讨论</a></h3>
<p>尽管强烈反对使用 ‘from module import <a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p02_control_the_import_of_everything.html#id7">*</a>’, 但是在定义了大量变量名的模块中频繁使用。 如果你不做任何事, 这样的导入将会导入所有不以下划线开头的。 </p>
<p>另一方面,如果定义了 <strong>all</strong> , 那么只有被列举出的东西会被导出。</p>
<p>如果你将 <strong>all</strong> 定义成一个空列表, 没有东西将被导入。 如果 <strong>all</strong> 包含未定义的名字, 在导入时引起AttributeError。</p>
<h2 id="使用相对路径名导入包中子模块"><a class="header" href="#使用相对路径名导入包中子模块">使用相对路径名导入包中子模块</a></h2>
<h3 id="问题-1"><a class="header" href="#问题-1">问题</a></h3>
<p>将代码组织成包,想用import语句从另一个包名没有硬编码过的包中导入子模块。</p>
<h3 id="解决方案-1"><a class="header" href="#解决方案-1">解决方案</a></h3>
<p>使用包的相对导入，使一个模块导入同一个包的另一个模块 举个例子，假设在你的文件系统上有mypackage包，组织如下：</p>
<pre><code>mypackage/
    __init__.py
    A/
        __init__.py
        spam.py
        grok.py
    B/
        __init__.py
        bar.py
</code></pre>
<p>如果模块mypackage.A.spam要导入同目录下的模块grok，它应该包括的import语句如下：</p>
<pre><code class="language-python"># mypackage/A/spam.py
from . import grok
</code></pre>
<p>如果模块mypackage.A.spam要导入不同目录下的模块B.bar，它应该使用的import语句如下：</p>
<pre><code class="language-python"># mypackage/A/spam.py
from ..B import bar
</code></pre>
<p>两个import语句都没包含顶层包名，而是使用了spam.py的相对路径。</p>
<h3 id="讨论-2"><a class="header" href="#讨论-2">讨论</a></h3>
<p>在包内，既可以使用相对路径也可以使用绝对路径来导入。 举个例子：</p>
<pre><code># mypackage/A/spam.py
from mypackage.A import grok # OK
from . import grok # OK
import grok # Error (not found)
</code></pre>
<ul>
<li>
<p>像mypackage.A这样使用绝对路径名的不利之处是这将顶层包名硬编码到你的源码中。如果你想重新组织它，你的代码将更脆，很难工作。 </p>
</li>
<li>
<p>举个例子，如果你改变了包名，你就必须检查所有文件来修正源码。</p>
</li>
<li>
<p>同样，硬编码的名称会使移动代码变得困难。举个例子，也许有人想安装两个不同版本的软件包，只通过名称区分它们。 如果使用相对导入，那一切都ok，然而使用绝对路径名很可能会出问题。</p>
</li>
</ul>
<p>import语句的 <code>.</code> 和 <code>..</code> 看起来很滑稽, 但它指定目录名.为当前目录，..B为目录../B。这种语法只适用于import。 举个例子：</p>
<pre><code>from . import grok # OK
import .grok # ERROR
</code></pre>
<p>尽管使用相对导入看起来像是浏览文件系统，但是不能到定义包的目录之外。也就是说，使用点的这种模式从不是包的目录中导入将会引发错误。</p>
<p>最后，相对导入只适用于在合适的包中的模块。尤其是在顶层的脚本的简单模块中，它们将不起作用。如果包的部分被作为脚本直接执行，那它们将不起作用 例如：</p>
<pre><code>% python3 mypackage/A/spam.py # Relative imports fail
</code></pre>
<p>另一方面，如果你使用Python的-m选项来执行先前的脚本，相对导入将会正确运行。 例如：</p>
<pre><code>% python3 -m mypackage.A.spam # Relative imports work
</code></pre>
<p>更多的包的相对导入的背景知识,请看 <a href="http://www.python.org/dev/peps/pep-0328">PEP 328</a> .</p>
<h2 id="将模块分割成多个文件"><a class="header" href="#将模块分割成多个文件">将模块分割成多个文件</a></h2>
<h3 id="问题-2"><a class="header" href="#问题-2">问题</a></h3>
<p>你想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。</p>
<h2 id="解决方案-2"><a class="header" href="#解决方案-2">解决方案</a></h2>
<p>程序模块可以通过变成包来分割成多个独立的文件。考虑下下面简单的模块：</p>
<pre><code># mymodule.py
class A:
    def spam(self):
        print('A.spam')

class B(A):
    def bar(self):
        print('B.bar')
</code></pre>
<p>假设你想mymodule.py分为两个文件，每个定义的一个类。要做到这一点，首先用mymodule目录来替换文件mymodule.py。 这这个目录下，创建以下文件：</p>
<pre><code>mymodule/
    __init__.py
    a.py
    b.py
</code></pre>
<p>在a.py文件中插入以下代码：</p>
<pre><code># a.py
class A:
    def spam(self):
        print('A.spam')
</code></pre>
<p>在b.py文件中插入以下代码：</p>
<pre><code># b.py
from .a import A
class B(A):
    def bar(self):
        print('B.bar')
</code></pre>
<p>最后，在 <strong>init</strong>.py 中，将2个文件粘合在一起：</p>
<pre><code># __init__.py
from .a import A
from .b import B
</code></pre>
<p>如果按照这些步骤，所产生的包MyModule将作为一个单一的逻辑模块：</p>
<pre><code>&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; a = mymodule.A()
&gt;&gt;&gt; a.spam()
A.spam
&gt;&gt;&gt; b = mymodule.B()
&gt;&gt;&gt; b.bar()
B.bar
&gt;&gt;&gt;
</code></pre>
<h3 id="讨论-3"><a class="header" href="#讨论-3">讨论</a></h3>
<p>在这个章节中的主要问题是一个设计问题，不管你是否希望用户使用很多小模块或只是一个模块。举个例子，在一个大型的代码库中，你可以将这一切都分割成独立的文件，让用户使用大量的import语句，就像这样：</p>
<pre><code>from mymodule.a import A
from mymodule.b import B
...
</code></pre>
<p>这样能工作，但这让用户承受更多的负担，用户要知道不同的部分位于何处。通常情况下，将这些统一起来，使用一条import将更加容易，就像这样：</p>
<pre><code>from mymodule import A, B
</code></pre>
<p>对后者而言，让mymodule成为一个大的源文件是最常见的。但是，这一章节展示了如何合并多个文件合并成一个单一的逻辑命名空间。 这样做的关键是创建一个包目录，使用 <strong>init</strong>.py 文件来将每部分粘合在一起。</p>
<p>当一个模块被分割，你需要特别注意交叉引用的文件名。举个例子，在这一章节中，B类需要访问A类作为基类。用包的相对导入 from .a import A 来获取。</p>
<p>整个章节都使用包的相对导入来避免将顶层模块名硬编码到源代码中。这使得重命名模块或者将它移动到别的位置更容易。（见10.3小节）</p>
<p>作为这一章节的延伸，将介绍延迟导入。如图所示，<strong>init</strong>.py文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。 要做到这一点，<strong>init</strong>.py有细微的变化：</p>
<pre><code># __init__.py
def A():
    from .a import A
    return A()

def B():
    from .b import B
    return B()
</code></pre>
<p>在这个版本中，类A和类B被替换为在第一次访问时加载所需的类的函数。对于用户，这看起来不会有太大的不同。 例如：</p>
<pre><code>&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; a = mymodule.A()
&gt;&gt;&gt; a.spam()
A.spam
&gt;&gt;&gt;
</code></pre>
<p>延迟加载的主要缺点是继承和类型检查可能会中断。你可能会稍微改变你的代码，例如:</p>
<pre><code>if isinstance(x, mymodule.A): # Error
...

if isinstance(x, mymodule.a.A): # Ok
...
</code></pre>
<p>延迟加载的真实例子, 见标准库 multiprocessing/<strong>init</strong>.py 的源码.</p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p05_separate_directories_import_by_namespace.html">Next </a><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p03_import_submodules_by_relative_names.html"> Previous</a></p>
<h2 id="利用命名空间导入目录分散的代码"><a class="header" href="#利用命名空间导入目录分散的代码">利用命名空间导入目录分散的代码</a></h2>
<h3 id="问题-3"><a class="header" href="#问题-3">问题</a></h3>
<p>你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。</p>
<h3 id="解决方案-3"><a class="header" href="#解决方案-3">解决方案</a></h3>
<p>从本质上讲，你要定义一个顶级Python包，作为一个大集合分开维护子包的命名空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。</p>
<p>在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来的__init__.py文件。假设你有Python代码的两个不同的目录如下：</p>
<pre><code>foo-package/
    spam/
        blah.py

bar-package/
    spam/
        grok.py
</code></pre>
<p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有__init__.py文件。</p>
<p>让我们看看，如果将foo-package和bar-package都加到python模块路径并尝试导入会发生什么</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.extend(['foo-package', 'bar-package'])
&gt;&gt;&gt; import spam.blah
&gt;&gt;&gt; import spam.grok
&gt;&gt;&gt;
</code></pre>
<p>两个不同的包目录被合并到一起，你可以导入spam.blah和spam.grok，并且它们能够工作。</p>
<h3 id="讨论-4"><a class="header" href="#讨论-4">讨论</a></h3>
<ul>
<li>
<p>在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。</p>
</li>
<li>
<p>对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p>
</li>
<li>
<p>包命名空间的关键是确保顶级目录中没有__init__.py文件来作为共同的命名空间。缺失__init__.py文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其__path__变量中。 举个例子：</p>
</li>
</ul>
<pre><code>&gt;&gt;&gt; import spam
&gt;&gt;&gt; spam.__path__
_NamespacePath(['foo-package/spam', 'bar-package/spam'])
&gt;&gt;&gt;
</code></pre>
<p>在定位包的子组件时，目录__path__将被用到(例如, 当导入spam.grok或者spam.blah的时候).</p>
<p>包命名空间的一个重要特点是任何人都可以用自己的代码来扩展命名空间。举个例子，假设你自己的代码目录像这样：</p>
<pre><code>my-package/
    spam/
        custom.py
</code></pre>
<p>如果你将你的代码目录和其他包一起添加到sys.path，这将无缝地合并到别的spam包目录中：</p>
<pre><code>&gt;&gt;&gt; import spam.custom
&gt;&gt;&gt; import spam.grok
&gt;&gt;&gt; import spam.blah
&gt;&gt;&gt;
</code></pre>
<p>一个包是否被作为一个包命名空间的主要方法是检查其__file__属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。</p>
<pre><code>&gt;&gt;&gt; spam.__file__
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute '__file__'
&gt;&gt;&gt; spam
&lt;module 'spam' (namespace)&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="重新加载模块"><a class="header" href="#重新加载模块">重新加载模块</a></h2>
<h3 id="问题-4"><a class="header" href="#问题-4">问题</a></h3>
<p>你想重新加载已经加载的模块，因为你对其源码进行了修改。</p>
<h3 id="解决方案-4"><a class="header" href="#解决方案-4">解决方案</a></h3>
<p>使用imp.reload()来重新加载先前加载的模块。举个例子：</p>
<pre><code>&gt;&gt;&gt; import spam
&gt;&gt;&gt; import imp
&gt;&gt;&gt; imp.reload(spam)
&lt;module 'spam' from './spam.py'&gt;
&gt;&gt;&gt;
</code></pre>
<h3 id="讨论-5"><a class="header" href="#讨论-5">讨论</a></h3>
<p>重新加载模块在开发和调试过程中常常很有用。但在生产环境中的代码使用会不安全，因为它并不总是像您期望的那样工作。</p>
<p>reload()擦除了模块底层字典的内容，并通过重新执行模块的源代码来刷新它。模块对象本身的身份保持不变。因此，该操作在程序中所有已经被导入了的地方更新了模块。</p>
<p>尽管如此，reload()没有更新像”from module import name”这样使用import语句导入的定义。举个例子：</p>
<pre><code># spam.py
def bar():
    print('bar')

def grok():
    print('grok')
</code></pre>
<p>现在启动交互式会话：</p>
<pre><code>&gt;&gt;&gt; import spam
&gt;&gt;&gt; from spam import grok
&gt;&gt;&gt; spam.bar()
bar
&gt;&gt;&gt; grok()
grok
&gt;&gt;&gt;
</code></pre>
<p>不退出Python修改spam.py的源码，将grok()函数改成这样：</p>
<pre><code>def grok():
    print('New grok')
</code></pre>
<p>现在回到交互式会话，重新加载模块，尝试下这个实验：</p>
<pre><code>&gt;&gt;&gt; import imp
&gt;&gt;&gt; imp.reload(spam)
&lt;module 'spam' from './spam.py'&gt;
&gt;&gt;&gt; spam.bar()
bar
&gt;&gt;&gt; grok() # Notice old output
grok
&gt;&gt;&gt; spam.grok() # Notice new output
New grok
&gt;&gt;&gt;
</code></pre>
<p>在这个例子中，你看到有2个版本的grok()函数被加载。通常来说，这不是你想要的，而是令人头疼的事。</p>
<p>因此，在生产环境中可能需要避免重新加载模块。在交互环境下调试，解释程序并试图弄懂它。</p>
<h2 id="运行目录或压缩文件"><a class="header" href="#运行目录或压缩文件">运行目录或压缩文件</a></h2>
<h3 id="问题-5"><a class="header" href="#问题-5">问题</a></h3>
<p>您有一个已成长为包含多个文件的应用，它已远不再是一个简单的脚本，你想向用户提供一些简单的方法运行这个程序。</p>
<h3 id="解决方案-5"><a class="header" href="#解决方案-5">解决方案</a></h3>
<p>如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个__main__.py文件。 举个例子，你可以像这样创建目录：</p>
<pre><code>myapplication/
    spam.py
    bar.py
    grok.py
    __main__.py
</code></pre>
<p>如果__main__.py存在，你可以简单地在顶级目录运行Python解释器：</p>
<pre><code>bash % python3 myapplication
</code></pre>
<p>解释器将执行<code>__main__</code>.py文件作为主程序。</p>
<p>如果你将你的代码打包成zip文件，这种技术同样也适用，举个例子：</p>
<pre><code>bash % ls
spam.py bar.py grok.py __main__.py
bash % zip -r myapp.zip *.py
bash % python3 myapp.zip
... output from __main__.py ...
</code></pre>
<h3 id="讨论-6"><a class="header" href="#讨论-6">讨论</a></h3>
<p>创建一个目录或zip文件并添加__main__.py文件来将一个更大的Python应用打包是可行的。这和作为标准库被安装到Python库的代码包是有一点区别的。相反，这只是让别人执行的代码包。</p>
<p>由于目录和zip文件与正常文件有一点不同，你可能还需要增加一个shell脚本，使执行更加容易。例如，如果代码文件名为myapp.zip，你可以创建这样一个顶级脚本：</p>
<pre><code>#!/usr/bin/env python3 /usr/local/bin/myapp.zip
</code></pre>
<h2 id="读取位于包中的数据文件"><a class="header" href="#读取位于包中的数据文件">读取位于包中的数据文件</a></h2>
<h3 id="问题-6"><a class="header" href="#问题-6">问题</a></h3>
<p>你的包中包含代码需要去读取的数据文件。你需要尽可能地用最便捷的方式来做这件事。</p>
<h3 id="解决方案-6"><a class="header" href="#解决方案-6">解决方案</a></h3>
<p>假设你的包中的文件组织成如下：</p>
<pre><code>mypackage/
    __init__.py
    somedata.dat
    spam.py
</code></pre>
<p>现在假设spam.py文件需要读取somedata.dat文件中的内容。你可以用以下代码来完成：</p>
<pre><code class="language-python"># spam.py
import pkgutil
data = pkgutil.get_data(__package__, 'somedata.dat')
</code></pre>
<p>由此产生的变量是包含该文件的原始内容的字节字符串。</p>
<h3 id="讨论-7"><a class="header" href="#讨论-7">讨论</a></h3>
<p>要读取数据文件，你可能会倾向于编写使用内置的I/ O功能的代码，如open()。但是这种方法也有一些问题。</p>
<ul>
<li>
<p>首先，一个包对解释器的当前工作目录几乎没有控制权。因此，编程时任何I/O操作都必须使用绝对文件名。由于每个模块包含有完整路径的__file__变量，这弄清楚它的路径不是不可能，但它很凌乱。</p>
</li>
<li>
<p>第二，包通常安装作为.zip或.egg文件，这些文件并不像在文件系统上的一个普通目录里那样被保存。因此，你试图用open()对一个包含数据文件的归档文件进行操作，它根本不会工作。</p>
</li>
<li>
<p>pkgutil.get_data()函数是一个读取数据文件的高级工具，不用管包是如何安装以及安装在哪。它只是工作并将文件内容以字节字符串返回给你</p>
</li>
</ul>
<p>get_data()的第一个参数是包含包名的字符串。你可以直接使用包名，也可以使用特殊的变量，比如__package__。第二个参数是包内文件的相对名称。如果有必要，可以使用标准的Unix命名规范到不同的目录，只要最后的目录仍然位于包中。</p>
<h2 id="将文件夹加入到syspath"><a class="header" href="#将文件夹加入到syspath">将文件夹加入到sys.path</a></h2>
<h3 id="问题-7"><a class="header" href="#问题-7">问题</a></h3>
<p>你无法导入你的Python代码因为它所在的目录不在sys.path里。你想将添加新目录到Python路径，但是不想硬链接到你的代码。</p>
<h3 id="解决方案-7"><a class="header" href="#解决方案-7">解决方案</a></h3>
<p>有两种常用的方式将新目录添加到sys.path。第一种，你可以使用PYTHONPATH环境变量来添加。例如：</p>
<pre><code>bash % env PYTHONPATH=/some/dir:/other/dir python3
Python 3.3.0 (default, Oct 4 2012, 10:17:33)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/some/dir', '/other/dir', ...]
&gt;&gt;&gt;
</code></pre>
<p>在自定义应用程序中，这样的环境变量可在程序启动时设置或通过shell脚本。</p>
<p><strong>第二种方法是创建一个.pth文件，将目录列举出来，像这样：</strong></p>
<pre><code># myapplication.pth
/some/dir
/other/dir
</code></pre>
<p>这个.pth文件需要放在某个Python的site-packages目录，通常位于/usr/local/lib/python3.3/site-packages 或者 ~/.local/lib/python3.3/sitepackages。当解释器启动时，.pth文件里列举出来的存在于文件系统的目录将被添加到sys.path。安装一个.pth文件可能需要管理员权限，如果它被添加到系统级的Python解释器。</p>
<h3 id="讨论-8"><a class="header" href="#讨论-8">讨论</a></h3>
<p>比起费力地找文件，你可能会倾向于写一个代码手动调节sys.path的值。例如:</p>
<pre><code>import sys
sys.path.insert(0, '/some/dir')
sys.path.insert(0, '/other/dir')
</code></pre>
<p>虽然这能“工作”，但是在实践中极为脆弱，应尽量避免使用。这种方法的问题是，它将目录名硬编码到了你的源代码。如果你的代码被移到一个新的位置，这会导致维护问题。更好的做法是在不修改源代码的情况下，将path配置到其他地方。如果您使用模块级的变量来精心构造一个适当的绝对路径，有时你可以解决硬编码目录的问题，比如__file__。举个例子：</p>
<pre><code>import sys
from os.path import abspath, join, dirname
sys.path.insert(0, join(abspath(dirname(__file__)), 'src'))
</code></pre>
<p>这将src目录添加到path里，和执行插入步骤的代码在同一个目录里。</p>
<p>site-packages目录是第三方包和模块安装的目录。如果你手动安装你的代码，它将被安装到site-packages目录。虽然用于配置path的.pth文件必须放置在site-packages里，但它配置的路径可以是系统上任何你希望的目录。因此，你可以把你的代码放在一系列不同的目录，只要那些目录包含在.pth文件里。</p>
<h2 id="通过字符串名导入模块"><a class="header" href="#通过字符串名导入模块">通过字符串名导入模块</a></h2>
<h3 id="问题-8"><a class="header" href="#问题-8">问题</a></h3>
<p>你想导入一个模块，但是模块的名字在字符串里。你想对字符串调用导入命令。</p>
<h3 id="解决方案-8"><a class="header" href="#解决方案-8">解决方案</a></h3>
<p>使用importlib.import_module()函数来手动导入名字为字符串给出的一个模块或者包的一部分。举个例子：</p>
<pre><code class="language-python">&gt;&gt;&gt; import importlib
&gt;&gt;&gt; math = importlib.import_module('math')
&gt;&gt;&gt; math.sin(2)
0.9092974268256817
&gt;&gt;&gt; mod = importlib.import_module('urllib.request')
&gt;&gt;&gt; u = mod.urlopen('http://www.python.org')
&gt;&gt;&gt;
</code></pre>
<p>import_module只是简单地执行和import相同的步骤，但是返回生成的模块对象。你只需要将其存储在一个变量，然后像正常的模块一样使用。</p>
<p>如果你正在使用的包，import_module()也可用于相对导入。但是，你需要给它一个额外的参数。例如：</p>
<pre><code class="language-python">import importlib
# Same as 'from . import b'
b = importlib.import_module('.b', __package__)
</code></pre>
<h3 id="讨论-9"><a class="header" href="#讨论-9">讨论</a></h3>
<p>使用import_module()手动导入模块的问题通常出现在以某种方式编写修改或覆盖模块的代码时候。例如，也许你正在执行某种自定义导入机制，需要通过名称来加载一个模块，通过补丁加载代码。</p>
<p>在旧的代码，有时你会看到用于导入的内建函数__import__()。尽管它能工作，但是importlib.import_module() 通常更容易使用。</p>
<p>自定义导入过程的高级实例 钩子远程加载模块</p>
<h2 id="通过钩子远程加载模块"><a class="header" href="#通过钩子远程加载模块">通过钩子远程加载模块</a></h2>
<h3 id="问题-9"><a class="header" href="#问题-9">问题</a></h3>
<p>你想自定义Python的import语句，使得它能从远程机器上面透明的加载模块。</p>
<h3 id="解决方案-9"><a class="header" href="#解决方案-9">解决方案</a></h3>
<p>首先要提出来的是安全问题。本节讨论的思想如果没有一些额外的安全和认知机制的话会很糟糕。 也就是说，我们的主要目的是深入分析Python的import语句机制。 如果你理解了本节内部原理，你就能够为其他任何目的而自定义import。 有了这些，让我们继续向前走。</p>
<p>本节核心是设计导入语句的扩展功能。有很多种方法可以做这个， 不过为了演示的方便，我们开始先构造下面这个Python代码结构：</p>
<pre><code>testcode/
    spam.py
    fib.py
    grok/
        __init__.py
        blah.py
</code></pre>
<p>这些文件的内容并不重要，不过我们在每个文件中放入了少量的简单语句和函数， 这样你可以测试它们并查看当它们被导入时的输出。例如：</p>
<pre><code># spam.py
print(&quot;I'm spam&quot;)

def hello(name):
    print('Hello %s' % name)

# fib.py
print(&quot;I'm fib&quot;)

def fib(n):
    if n &lt; 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)

# grok/__init__.py
print(&quot;I'm grok.__init__&quot;)

# grok/blah.py
print(&quot;I'm grok.blah&quot;)
</code></pre>
<p>这里的目的是允许这些文件作为模块被远程访问。 也许最简单的方式就是将它们发布到一个web服务器上面。在testcode目录中像下面这样运行Python：</p>
<pre><code>bash % cd testcode
bash % python3 -m http.server 15000
Serving HTTP on 0.0.0.0 port 15000 ...
</code></pre>
<p>服务器运行起来后再启动一个单独的Python解释器。 确保你可以使用 <code>urllib</code> 访问到远程文件。例如：</p>
<pre><code>&gt;&gt;&gt; from urllib.request import urlopen
&gt;&gt;&gt; u = urlopen('http://localhost:15000/fib.py')
&gt;&gt;&gt; data = u.read().decode('utf-8')
&gt;&gt;&gt; print(data)
# fib.py
print(&quot;I'm fib&quot;)

def fib(n):
    if n &lt; 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)
&gt;&gt;&gt;
</code></pre>
<p>从这个服务器加载源代码是接下来本节的基础。 为了替代手动的通过 <code>urlopen()</code> 来收集源文件， 我们通过自定义import语句来在后台自动帮我们做到。</p>
<p>加载远程模块的第一种方法是创建一个显式的加载函数来完成它。例如：</p>
<pre><code>import imp
import urllib.request
import sys

def load_module(url):
    u = urllib.request.urlopen(url)
    source = u.read().decode('utf-8')
    mod = sys.modules.setdefault(url, imp.new_module(url))
    code = compile(source, url, 'exec')
    mod.__file__ = url
    mod.__package__ = ''
    exec(code, mod.__dict__)
    return mod
</code></pre>
<p>这个函数会下载源代码，并使用 <code>compile()</code> 将其编译到一个代码对象中， 然后在一个新创建的模块对象的字典中来执行它。下面是使用这个函数的方式：</p>
<pre><code>&gt;&gt;&gt; fib = load_module('http://localhost:15000/fib.py')
I'm fib
&gt;&gt;&gt; fib.fib(10)
89
&gt;&gt;&gt; spam = load_module('http://localhost:15000/spam.py')
I'm spam
&gt;&gt;&gt; spam.hello('Guido')
Hello Guido
&gt;&gt;&gt; fib
&lt;module 'http://localhost:15000/fib.py' from 'http://localhost:15000/fib.py'&gt;
&gt;&gt;&gt; spam
&lt;module 'http://localhost:15000/spam.py' from 'http://localhost:15000/spam.py'&gt;
&gt;&gt;&gt;
</code></pre>
<p>正如你所见，对于简单的模块这个是行得通的。 不过它并没有嵌入到通常的import语句中，如果要支持更高级的结构比如包就需要更多的工作了。</p>
<p>一个更酷的做法是创建一个自定义导入器。第一种方法是创建一个元路径导入器。如下：</p>
<pre><code class="language-python"># urlimport.py
import sys
import importlib.abc
import imp
from urllib.request import urlopen
from urllib.error import HTTPError, URLError
from html.parser import HTMLParser

# Debugging
import logging
log = logging.getLogger(__name__)

# Get links from a given URL
def _get_links(url):
    class LinkParser(HTMLParser):
        def handle_starttag(self, tag, attrs):
            if tag == 'a':
                attrs = dict(attrs)
                links.add(attrs.get('href').rstrip('/'))
    links = set()
    try:
        log.debug('Getting links from %s' % url)
        u = urlopen(url)
        parser = LinkParser()
        parser.feed(u.read().decode('utf-8'))
    except Exception as e:
        log.debug('Could not get links. %s', e)
    log.debug('links: %r', links)
    return links

class UrlMetaFinder(importlib.abc.MetaPathFinder):
    def __init__(self, baseurl):
        self._baseurl = baseurl
        self._links = { }
        self._loaders = { baseurl : UrlModuleLoader(baseurl) }

    def find_module(self, fullname, path=None):
        log.debug('find_module: fullname=%r, path=%r', fullname, path)
        if path is None:
            baseurl = self._baseurl
        else:
            if not path[0].startswith(self._baseurl):
                return None
            baseurl = path[0]
        parts = fullname.split('.')
        basename = parts[-1]
        log.debug('find_module: baseurl=%r, basename=%r', baseurl, basename)

        # Check link cache
        if basename not in self._links:
            self._links[baseurl] = _get_links(baseurl)

        # Check if it's a package
        if basename in self._links[baseurl]:
            log.debug('find_module: trying package %r', fullname)
            fullurl = self.base_url + '/' + basename
            # Attempt to load the package (which accesses __init__.py)
            loader = UrlPackageLoader(fullurl)
            try:
                loader.load_module(fullname)
                self._links[fullurl] = _get_links(fullurl)
                self._loaders[fullurl] = UrlModuleLoader(fullurl)
                log.debug('find_module: package %r loaded', fullname)
            except ImportError as e:
                log.debug('find_module: package failed. %s', e)
                loader = None
            return loader
        # A normal module
        filename = basename + '.py'
        if filename in self._links[baseurl]:
            log.debug('find_module: module %r found', fullname)
            return self._loaders[baseurl]
        else:
            log.debug('find_module: module %r not found', fullname)
            return None

    def invalidate_caches(self):
        log.debug('invalidating link cache')
        self._links.clear()

# Module Loader for a URL
class UrlModuleLoader(importlib.abc.SourceLoader):
    def __init__(self, baseurl):
        self._baseurl = baseurl
        self._source_cache = {}

    def module_repr(self, module):
        return '&lt;urlmodule %r from %r&gt;' % (module.__name__, module.__file__)

    # Required method
    def load_module(self, fullname):
        code = self.get_code(fullname)
        mod = sys.modules.setdefault(fullname, imp.new_module(fullname))
        mod.__file__ = self.get_filename(fullname)
        mod.__loader__ = self
        mod.__package__ = fullname.rpartition('.')[0]
        exec(code, mod.__dict__)
        return mod

    # Optional extensions
    def get_code(self, fullname):
        src = self.get_source(fullname)
        return compile(src, self.get_filename(fullname), 'exec')

    def get_data(self, path):
        pass

    def get_filename(self, fullname):
        return self._baseurl + '/' + fullname.split('.')[-1] + '.py'

    def get_source(self, fullname):
        filename = self.get_filename(fullname)
        log.debug('loader: reading %r', filename)
        if filename in self._source_cache:
            log.debug('loader: cached %r', filename)
            return self._source_cache[filename]
        try:
            u = urlopen(filename)
            source = u.read().decode('utf-8')
            log.debug('loader: %r loaded', filename)
            self._source_cache[filename] = source
            return source
        except (HTTPError, URLError) as e:
            log.debug('loader: %r failed. %s', filename, e)
            raise ImportError(&quot;Can't load %s&quot; % filename)

    def is_package(self, fullname):
        return False

# Package loader for a URL
class UrlPackageLoader(UrlModuleLoader):
    def load_module(self, fullname):
        mod = super().load_module(fullname)
        mod.__path__ = [ self._baseurl ]
        mod.__package__ = fullname

    def get_filename(self, fullname):
        return self._baseurl + '/' + '__init__.py'

    def is_package(self, fullname):
        return True

# Utility functions for installing/uninstalling the loader
_installed_meta_cache = { }
def install_meta(address):
    if address not in _installed_meta_cache:
        finder = UrlMetaFinder(address)
        _installed_meta_cache[address] = finder
        sys.meta_path.append(finder)
        log.debug('%r installed on sys.meta_path', finder)

def remove_meta(address):
    if address in _installed_meta_cache:
        finder = _installed_meta_cache.pop(address)
        sys.meta_path.remove(finder)
        log.debug('%r removed from sys.meta_path', finder)
</code></pre>
<p>下面是一个交互会话，演示了如何使用前面的代码：</p>
<pre><code class="language-python">&gt;&gt;&gt; # importing currently fails
&gt;&gt;&gt; import fib
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'
&gt;&gt;&gt; # Load the importer and retry (it works)
&gt;&gt;&gt; import urlimport
&gt;&gt;&gt; urlimport.install_meta('http://localhost:15000')
&gt;&gt;&gt; import fib
I'm fib
&gt;&gt;&gt; import spam
I'm spam
&gt;&gt;&gt; import grok.blah
I'm grok.__init__
I'm grok.blah
&gt;&gt;&gt; grok.blah.__file__
'http://localhost:15000/grok/blah.py'
&gt;&gt;&gt;
</code></pre>
<p>这个特殊的方案会安装一个特别的查找器 <code>UrlMetaFinder</code> 实例， 作为 <code>sys.meta_path</code> 中最后的实体。 当模块被导入时，会依据 <code>sys.meta_path</code> 中的查找器定位模块。 在这个例子中，<code>UrlMetaFinder</code> 实例是最后一个查找器方案， 当模块在任何一个普通地方都找不到的时候就触发它。</p>
<p>作为常见的实现方案，<code>UrlMetaFinder</code> 类包装在一个用户指定的URL上。 在内部，查找器通过抓取指定URL的内容构建合法的链接集合。 导入的时候，模块名会跟已有的链接作对比。如果找到了一个匹配的， 一个单独的 <code>UrlModuleLoader</code> 类被用来从远程机器上加载源代码并创建最终的模块对象。 这里缓存链接的一个原因是避免不必要的HTTP请求重复导入。</p>
<p>自定义导入的第二种方法是编写一个钩子直接嵌入到 <code>sys.path</code> 变量中去， 识别某些目录命名模式。 在 <code>urlimport.py</code> 中添加如下的类和支持函数：</p>
<pre><code># urlimport.py
# ... include previous code above ...
# Path finder class for a URL
class UrlPathFinder(importlib.abc.PathEntryFinder):
    def __init__(self, baseurl):
        self._links = None
        self._loader = UrlModuleLoader(baseurl)
        self._baseurl = baseurl

    def find_loader(self, fullname):
        log.debug('find_loader: %r', fullname)
        parts = fullname.split('.')
        basename = parts[-1]
        # Check link cache
        if self._links is None:
            self._links = [] # See discussion
            self._links = _get_links(self._baseurl)

        # Check if it's a package
        if basename in self._links:
            log.debug('find_loader: trying package %r', fullname)
            fullurl = self._baseurl + '/' + basename
            # Attempt to load the package (which accesses __init__.py)
            loader = UrlPackageLoader(fullurl)
            try:
                loader.load_module(fullname)
                log.debug('find_loader: package %r loaded', fullname)
            except ImportError as e:
                log.debug('find_loader: %r is a namespace package', fullname)
                loader = None
            return (loader, [fullurl])

        # A normal module
        filename = basename + '.py'
        if filename in self._links:
            log.debug('find_loader: module %r found', fullname)
            return (self._loader, [])
        else:
            log.debug('find_loader: module %r not found', fullname)
            return (None, [])

    def invalidate_caches(self):
        log.debug('invalidating link cache')
        self._links = None

# Check path to see if it looks like a URL
_url_path_cache = {}
def handle_url(path):
    if path.startswith(('http://', 'https://')):
        log.debug('Handle path? %s. [Yes]', path)
        if path in _url_path_cache:
            finder = _url_path_cache[path]
        else:
            finder = UrlPathFinder(path)
            _url_path_cache[path] = finder
        return finder
    else:
        log.debug('Handle path? %s. [No]', path)

def install_path_hook():
    sys.path_hooks.append(handle_url)
    sys.path_importer_cache.clear()
    log.debug('Installing handle_url')

def remove_path_hook():
    sys.path_hooks.remove(handle_url)
    sys.path_importer_cache.clear()
    log.debug('Removing handle_url')
</code></pre>
<p>要使用这个路径查找器，你只需要在 <code>sys.path</code> 中加入URL链接。例如：</p>
<pre><code>&gt;&gt;&gt; # Initial import fails
&gt;&gt;&gt; import fib
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'

&gt;&gt;&gt; # Install the path hook
&gt;&gt;&gt; import urlimport
&gt;&gt;&gt; urlimport.install_path_hook()

&gt;&gt;&gt; # Imports still fail (not on path)
&gt;&gt;&gt; import fib
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'

&gt;&gt;&gt; # Add an entry to sys.path and watch it work
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('http://localhost:15000')
&gt;&gt;&gt; import fib
I'm fib
&gt;&gt;&gt; import grok.blah
I'm grok.__init__
I'm grok.blah
&gt;&gt;&gt; grok.blah.__file__
'http://localhost:15000/grok/blah.py'
&gt;&gt;&gt;
</code></pre>
<p>关键点就是 <code>handle_url()</code> 函数，它被添加到了 <code>sys.path_hooks</code> 变量中。 当 <code>sys.path</code> 的实体被处理时，会调用 <code>sys.path_hooks</code> 中的函数。 如果任何一个函数返回了一个查找器对象，那么这个对象就被用来为 <code>sys.path</code> 实体加载模块。</p>
<p>远程模块加载跟其他的加载使用方法几乎是一样的。例如：</p>
<pre><code>&gt;&gt;&gt; fib
&lt;urlmodule 'fib' from 'http://localhost:15000/fib.py'&gt;
&gt;&gt;&gt; fib.__name__
'fib'
&gt;&gt;&gt; fib.__file__
'http://localhost:15000/fib.py'
&gt;&gt;&gt; import inspect
&gt;&gt;&gt; print(inspect.getsource(fib))
# fib.py
print(&quot;I'm fib&quot;)

def fib(n):
    if n &lt; 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)
&gt;&gt;&gt;
</code></pre>
<h3 id="讨论-10"><a class="header" href="#讨论-10">讨论</a></h3>
<p>在详细讨论之前，有点要强调的是，Python的模块、包和导入机制是整个语言中最复杂的部分， 即使经验丰富的Python程序员也很少能精通它们。 我在这里推荐一些值的去读的文档和书籍，包括 <a href="https://docs.python.org/3/library/importlib.html">importlib module</a> 和 <a href="http://www.python.org/dev/peps/pep-0302">PEP 302</a>. 文档内容在这里不会被重复提到，不过我在这里会讨论一些最重要的部分。</p>
<p>首先，如果你想创建一个新的模块对象，使用 <code>imp.new_module()</code> 函数：</p>
<pre><code>&gt;&gt;&gt; import imp
&gt;&gt;&gt; m = imp.new_module('spam')
&gt;&gt;&gt; m
&lt;module 'spam'&gt;
&gt;&gt;&gt; m.__name__
'spam'
&gt;&gt;&gt;
</code></pre>
<p>模块对象通常有一些期望属性，包括 <code>__file__</code> （运行模块加载语句的文件名） 和 <code>__package__</code> (包名)。</p>
<p>其次，模块会被解释器缓存起来。模块缓存可以在字典 <code>sys.modules</code> 中被找到。 因为有了这个缓存机制，通常可以将缓存和模块的创建通过一个步骤完成：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import imp
&gt;&gt;&gt; m = sys.modules.setdefault('spam', imp.new_module('spam'))
&gt;&gt;&gt; m
&lt;module 'spam'&gt;
&gt;&gt;&gt;
</code></pre>
<p>如果给定模块已经存在那么就会直接获得已经被创建过的模块，例如：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; m = sys.modules.setdefault('math', imp.new_module('math'))
&gt;&gt;&gt; m
&lt;module 'math' from '/usr/local/lib/python3.3/lib-dynload/math.so'&gt;
&gt;&gt;&gt; m.sin(2)
0.9092974268256817
&gt;&gt;&gt; m.cos(2)
-0.4161468365471424
&gt;&gt;&gt;
</code></pre>
<p>由于创建模块很简单，很容易编写简单函数比如第一部分的 <code>load_module()</code> 函数。 这个方案的一个缺点是很难处理复杂情况比如包的导入。 为了处理一个包，你要重新实现普通import语句的底层逻辑（比如检查目录，查找__init__.py文件， 执行那些文件，设置路径等）。这个复杂性就是为什么最好直接扩展import语句而不是自定义函数的一个原因。</p>
<p>扩展import语句很简单，但是会有很多移动操作。 最高层上，导入操作被一个位于sys.meta_path列表中的“元路径”查找器处理。 如果你输出它的值，会看到下面这样：</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(sys.meta_path)
[&lt;class '_frozen_importlib.BuiltinImporter'&gt;,
&lt;class '_frozen_importlib.FrozenImporter'&gt;,
&lt;class '_frozen_importlib.PathFinder'&gt;]
&gt;&gt;&gt;
</code></pre>
<p>当执行一个语句比如 <code>import fib</code> 时，解释器会遍历sys.mata_path中的查找器对象， 调用它们的 <code>find_module()</code> 方法定位正确的模块加载器。 可以通过实验来看看：</p>
<pre><code>&gt;&gt;&gt; class Finder:
...     def find_module(self, fullname, path):
...         print('Looking for', fullname, path)
...         return None
...
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.meta_path.insert(0, Finder()) # Insert as first entry
&gt;&gt;&gt; import math
Looking for math None
&gt;&gt;&gt; import types
Looking for types None
&gt;&gt;&gt; import threading
Looking for threading None
Looking for time None
Looking for traceback None
Looking for linecache None
Looking for tokenize None
Looking for token None
&gt;&gt;&gt;
</code></pre>
<p>注意看 <code>find_module()</code> 方法是怎样在每一个导入就被触发的。 这个方法中的path参数的作用是处理包。 多个包被导入，就是一个可在包的 <code>__path__</code> 属性中找到的路径列表。 要找到包的子组件就要检查这些路径。 比如注意对于 <code>xml.etree</code> 和 <code>xml.etree.ElementTree</code> 的路径配置：</p>
<pre><code>&gt;&gt;&gt; import xml.etree.ElementTree
Looking for xml None
Looking for xml.etree ['/usr/local/lib/python3.3/xml']
Looking for xml.etree.ElementTree ['/usr/local/lib/python3.3/xml/etree']
Looking for warnings None
Looking for contextlib None
Looking for xml.etree.ElementPath ['/usr/local/lib/python3.3/xml/etree']
Looking for _elementtree None
Looking for copy None
Looking for org None
Looking for pyexpat None
Looking for ElementC14N None
&gt;&gt;&gt;
</code></pre>
<p>在 <code>sys.meta_path</code> 上查找器的位置很重要，将它从队头移到队尾，然后再试试导入看：</p>
<pre><code>&gt;&gt;&gt; del sys.meta_path[0]
&gt;&gt;&gt; sys.meta_path.append(Finder())
&gt;&gt;&gt; import urllib.request
&gt;&gt;&gt; import datetime
</code></pre>
<p>现在你看不到任何输出了，因为导入被sys.meta_path中的其他实体处理。 这时候，你只有在导入不存在模块的时候才能看到它被触发：</p>
<pre><code>&gt;&gt;&gt; import fib
Looking for fib None
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'
&gt;&gt;&gt; import xml.superfast
Looking for xml.superfast ['/usr/local/lib/python3.3/xml']
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'xml.superfast'
&gt;&gt;&gt;
</code></pre>
<p>你之前安装过一个捕获未知模块的查找器，这个是 <code>UrlMetaFinder</code> 类的关键。 一个 <code>UrlMetaFinder</code> 实例被添加到 <code>sys.meta_path</code> 的末尾，作为最后一个查找器方案。 如果被请求的模块名不能定位，就会被这个查找器处理掉。 处理包的时候需要注意，在path参数中指定的值需要被检查，看它是否以查找器中注册的URL开头。 如果不是，该子模块必须归属于其他查找器并被忽略掉。</p>
<p>对于包的其他处理可在 <code>UrlPackageLoader</code> 类中被找到。 这个类不会导入包名，而是去加载对应的 <code>__init__.py</code> 文件。 它也会设置模块的 <code>__path__</code> 属性，这一步很重要， 因为在加载包的子模块时这个值会被传给后面的 <code>find_module()</code> 调用。 基于路径的导入钩子是这些思想的一个扩展，但是采用了另外的方法。 我们都知道，<code>sys.path</code> 是一个Python查找模块的目录列表，例如：</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; import sys
&gt;&gt;&gt; pprint(sys.path)
['',
'/usr/local/lib/python33.zip',
'/usr/local/lib/python3.3',
'/usr/local/lib/python3.3/plat-darwin',
'/usr/local/lib/python3.3/lib-dynload',
'/usr/local/lib/...3.3/site-packages']
&gt;&gt;&gt;
</code></pre>
<p>在 <code>sys.path</code> 中的每一个实体都会被额外的绑定到一个查找器对象上。 你可以通过查看 <code>sys.path_importer_cache</code> 去看下这些查找器：</p>
<pre><code>&gt;&gt;&gt; pprint(sys.path_importer_cache)
{'.': FileFinder('.'),
'/usr/local/lib/python3.3': FileFinder('/usr/local/lib/python3.3'),
'/usr/local/lib/python3.3/': FileFinder('/usr/local/lib/python3.3/'),
'/usr/local/lib/python3.3/collections': FileFinder('...python3.3/collections'),
'/usr/local/lib/python3.3/encodings': FileFinder('...python3.3/encodings'),
'/usr/local/lib/python3.3/lib-dynload': FileFinder('...python3.3/lib-dynload'),
'/usr/local/lib/python3.3/plat-darwin': FileFinder('...python3.3/plat-darwin'),
'/usr/local/lib/python3.3/site-packages': FileFinder('...python3.3/site-packages'),
'/usr/local/lib/python33.zip': None}
&gt;&gt;&gt;
</code></pre>
<p><code>sys.path_importer_cache</code> 比 <code>sys.path</code> 会更大点， 因为它会为所有被加载代码的目录记录它们的查找器。 这包括包的子目录，这些通常在 <code>sys.path</code> 中是不存在的。</p>
<p>要执行 <code>import fib</code> ，会顺序检查 <code>sys.path</code> 中的目录。 对于每个目录，名称“fib”会被传给相应的 <code>sys.path_importer_cache</code> 中的查找器。 这个可以让你创建自己的查找器并在缓存中放入一个实体。试试这个：</p>
<pre><code>&gt;&gt;&gt; class Finder:
... def find_loader(self, name):
...     print('Looking for', name)
...     return (None, [])
...
&gt;&gt;&gt; import sys
&gt;&gt;&gt; # Add a &quot;debug&quot; entry to the importer cache
&gt;&gt;&gt; sys.path_importer_cache['debug'] = Finder()
&gt;&gt;&gt; # Add a &quot;debug&quot; directory to sys.path
&gt;&gt;&gt; sys.path.insert(0, 'debug')
&gt;&gt;&gt; import threading
Looking for threading
Looking for time
Looking for traceback
Looking for linecache
Looking for tokenize
Looking for token
&gt;&gt;&gt;
</code></pre>
<p>在这里，你可以为名字“debug”创建一个新的缓存实体并将它设置成 <code>sys.path</code> 上的第一个。 在所有接下来的导入中，你会看到你的查找器被触发了。 不过，由于它返回 (None, [])，那么处理进程会继续处理下一个实体。</p>
<p><code>sys.path_importer_cache</code> 的使用被一个存储在 <code>sys.path_hooks</code> 中的函数列表控制。 试试下面的例子，它会清除缓存并给 <code>sys.path_hooks</code> 添加一个新的路径检查函数</p>
<pre><code>&gt;&gt;&gt; sys.path_importer_cache.clear()
&gt;&gt;&gt; def check_path(path):
...     print('Checking', path)
...     raise ImportError()
...
&gt;&gt;&gt; sys.path_hooks.insert(0, check_path)
&gt;&gt;&gt; import fib
Checked debug
Checking .
Checking /usr/local/lib/python33.zip
Checking /usr/local/lib/python3.3
Checking /usr/local/lib/python3.3/plat-darwin
Checking /usr/local/lib/python3.3/lib-dynload
Checking /Users/beazley/.local/lib/python3.3/site-packages
Checking /usr/local/lib/python3.3/site-packages
Looking for fib
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'
&gt;&gt;&gt;
</code></pre>
<p>正如你所见，<code>check_path()</code> 函数被每个 <code>sys.path</code> 中的实体调用。 不顾，由于抛出了 <code>ImportError</code> 异常， 啥都不会发生了（仅仅将检查转移到sys.path_hooks的下一个函数）。</p>
<p>知道了怎样sys.path是怎样被处理的，你就能构建一个自定义路径检查函数来查找文件名，不然URL。例如：</p>
<pre><code>&gt;&gt;&gt; def check_url(path):
...     if path.startswith('http://'):
...         return Finder()
...     else:
...         raise ImportError()
...
&gt;&gt;&gt; sys.path.append('http://localhost:15000')
&gt;&gt;&gt; sys.path_hooks[0] = check_url
&gt;&gt;&gt; import fib
Looking for fib # Finder output!
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'

&gt;&gt;&gt; # Notice installation of Finder in sys.path_importer_cache
&gt;&gt;&gt; sys.path_importer_cache['http://localhost:15000']
&lt;__main__.Finder object at 0x10064c850&gt;
&gt;&gt;&gt;
</code></pre>
<p>这就是本节最后部分的关键点。事实上，一个用来在sys.path中查找URL的自定义路径检查函数已经构建完毕。 当它们被碰到的时候，一个新的 <code>UrlPathFinder</code> 实例被创建并被放入 <code>sys.path_importer_cache</code>. 之后，所有需要检查 <code>sys.path</code> 的导入语句都会使用你的自定义查找器。</p>
<p>基于路径导入的包处理稍微有点复杂，并且跟 <code>find_loader()</code> 方法返回值有关。 对于简单模块，<code>find_loader()</code> 返回一个元组(loader, None)， 其中的loader是一个用于导入模块的加载器实例。</p>
<p>对于一个普通的包，<code>find_loader()</code> 返回一个元组(loader, path)， 其中的loader是一个用于导入包（并执行__init__.py）的加载器实例， path是一个会初始化包的 <code>__path__</code> 属性的目录列表。 例如，如果基础URL是 <a href="http://localhost:15000/">http://localhost:15000</a> 并且一个用户执行 <code>import grok</code> , 那么 <code>find_loader()</code> 返回的path就会是 [ ‘http://localhost:15000/grok’ ]</p>
<p><code>find_loader()</code> 还要能处理一个命名空间包。 一个命名空间包中有一个合法的包目录名，但是不存在__init__.py文件。 这样的话，<code>find_loader()</code> 必须返回一个元组(None, path)， path是一个目录列表，由它来构建包的定义有__init__.py文件的__path__属性。 对于这种情况，导入机制会继续前行去检查sys.path中的目录。 如果找到了命名空间包，所有的结果路径被加到一起来构建最终的命名空间包。 关于命名空间包的更多信息请参考10.5小节。</p>
<p>所有的包都包含了一个内部路径设置，可以在__path__属性中看到，例如：</p>
<pre><code>&gt;&gt;&gt; import xml.etree.ElementTree
&gt;&gt;&gt; xml.__path__
['/usr/local/lib/python3.3/xml']
&gt;&gt;&gt; xml.etree.__path__
['/usr/local/lib/python3.3/xml/etree']
&gt;&gt;&gt;
</code></pre>
<p>之前提到，__path__的设置是通过 <code>find_loader()</code> 方法返回值控制的。 不过，__path__接下来也被sys.path_hooks中的函数处理。 因此，但包的子组件被加载后，位于__path__中的实体会被 <code>handle_url()</code> 函数检查。 这会导致新的 <code>UrlPathFinder</code> 实例被创建并且被加入到 <code>sys.path_importer_cache</code> 中。</p>
<p>还有个难点就是 <code>handle_url()</code> 函数以及它跟内部使用的 <code>_get_links()</code> 函数之间的交互。 如果你的查找器实现需要使用到其他模块（比如urllib.request）， 有可能这些模块会在查找器操作期间进行更多的导入。 它可以导致 <code>handle_url()</code> 和其他查找器部分陷入一种递归循环状态。 为了解释这种可能性，实现中有一个被创建的查找器缓存（每一个URL一个）。 它可以避免创建重复查找器的问题。 另外，下面的代码片段可以确保查找器不会在初始化链接集合的时候响应任何导入请求：</p>
<pre><code># Check link cache
if self._links is None:
    self._links = [] # See discussion
    self._links = _get_links(self._baseurl)
</code></pre>
<p>最后，查找器的 <code>invalidate_caches()</code> 方法是一个工具方法，用来清理内部缓存。 这个方法再用户调用 <code>importlib.invalidate_caches()</code> 的时候被触发。 如果你想让URL导入者重新读取链接列表的话可以使用它。</p>
<p>对比下两种方案（修改sys.meta_path或使用一个路径钩子）。 使用sys.meta_path的导入者可以按照自己的需要自由处理模块。 例如，它们可以从数据库中导入或以不同于一般模块/包处理方式导入。 这种自由同样意味着导入者需要自己进行内部的一些管理。 另外，基于路径的钩子只是适用于对sys.path的处理。 通过这种扩展加载的模块跟普通方式加载的特性是一样的。</p>
<p>如果到现在为止你还是不是很明白，那么可以通过增加一些日志打印来测试下本节。像下面这样：</p>
<pre><code class="language-python">&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG)
&gt;&gt;&gt; import urlimport
&gt;&gt;&gt; urlimport.install_path_hook()
DEBUG:urlimport:Installing handle_url
&gt;&gt;&gt; import fib
DEBUG:urlimport:Handle path? /usr/local/lib/python33.zip. [No]
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named 'fib'
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('http://localhost:15000')
&gt;&gt;&gt; import fib
DEBUG:urlimport:Handle path? http://localhost:15000. [Yes]
DEBUG:urlimport:Getting links from http://localhost:15000
DEBUG:urlimport:links: {'spam.py', 'fib.py', 'grok'}
DEBUG:urlimport:find_loader: 'fib'
DEBUG:urlimport:find_loader: module 'fib' found
DEBUG:urlimport:loader: reading 'http://localhost:15000/fib.py'
DEBUG:urlimport:loader: 'http://localhost:15000/fib.py' loaded
I'm fib
&gt;&gt;&gt;
</code></pre>
<p>最后，建议你花点时间看看 <a href="http://www.python.org/dev/peps/pep-0302">PEP 302</a> 以及importlib的文档。</p>
<h2 id="导入模块的同时修改模块"><a class="header" href="#导入模块的同时修改模块">导入模块的同时修改模块</a></h2>
<h3 id="问题-10"><a class="header" href="#问题-10">问题</a></h3>
<p>你想给某个已存在模块中的函数添加装饰器。 不过，前提是这个模块已经被导入并且被使用过。</p>
<h3 id="解决方案-10"><a class="header" href="#解决方案-10">解决方案</a></h3>
<p>这里问题的本质就是你想在模块被加载时执行某个动作。 可能是你想在一个模块被加载时触发某个回调函数来通知你。</p>
<p>这个问题可以使用10.11小节中同样的导入钩子机制来实现。下面是一个可能的方案：</p>
<pre><code class="language-python"># postimport.py
import importlib
import sys
from collections import defaultdict

_post_import_hooks = defaultdict(list)

class PostImportFinder:
    def __init__(self):
        self._skip = set()

    def find_module(self, fullname, path=None):
        if fullname in self._skip:
            return None
        self._skip.add(fullname)
        return PostImportLoader(self)

class PostImportLoader:
    def __init__(self, finder):
        self._finder = finder

    def load_module(self, fullname):
        importlib.import_module(fullname)
        module = sys.modules[fullname]
        for func in _post_import_hooks[fullname]:
            func(module)
        self._finder._skip.remove(fullname)
        return module

def when_imported(fullname):
    def decorate(func):
        if fullname in sys.modules:
            func(sys.modules[fullname])
        else:
            _post_import_hooks[fullname].append(func)
        return func
    return decorate

sys.meta_path.insert(0, PostImportFinder())
</code></pre>
<p>这样，你就可以使用 <code>when_imported()</code> 装饰器了，例如：</p>
<pre><code class="language-python">&gt;&gt;&gt; from postimport import when_imported
&gt;&gt;&gt; @when_imported('threading')
... def warn_threads(mod):
...     print('Threads? Are you crazy?')
...
&gt;&gt;&gt;
&gt;&gt;&gt; import threading
Threads? Are you crazy?
&gt;&gt;&gt;
</code></pre>
<p>作为一个更实际的例子，你可能想在已存在的定义上面添加装饰器，如下所示：</p>
<pre><code class="language-python">from functools import wraps
from postimport import when_imported

def logged(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('Calling', func.__name__, args, kwargs)
        return func(*args, **kwargs)
    return wrapper

# Example
@when_imported('math')
def add_logging(mod):
    mod.cos = logged(mod.cos)
    mod.sin = logged(mod.sin)
</code></pre>
<h3 id="讨论-11"><a class="header" href="#讨论-11">讨论</a></h3>
<p>本节技术依赖于10.11小节中讲述过的导入钩子，并稍作修改。</p>
<p><code>@when_imported</code> 装饰器的作用是注册在导入时被激活的处理器函数。 该装饰器检查sys.modules来查看模块是否真的已经被加载了。 如果是的话，该处理器被立即调用。不然，处理器被添加到 <code>_post_import_hooks</code> 字典中的一个列表中去。 <code>_post_import_hooks</code> 的作用就是收集所有的为每个模块注册的处理器对象。 一个模块可以注册多个处理器。</p>
<p>要让模块导入后触发添加的动作，<code>PostImportFinder</code> 类被设置为sys.meta_path第一个元素。 它会捕获所有模块导入操作。</p>
<p>本节中的 <code>PostImportFinder</code> 的作用并不是加载模块，而是自带导入完成后触发相应的动作。 实际的导入被委派给位于sys.meta_path中的其他查找器。 <code>PostImportLoader</code> 类中的 <code>imp.import_module()</code> 函数被递归的调用。 为了避免陷入无线循环，<code>PostImportFinder</code> 保持了一个所有被加载过的模块集合。 如果一个模块名存在就会直接被忽略掉。</p>
<p>当一个模块被 <code>imp.import_module()</code> 加载后， 所有在_post_import_hooks被注册的处理器被调用，使用新加载模块作为一个参数。</p>
<p>有一点需要注意的是本机不适用于那些通过 <code>imp.reload()</code> 被显式加载的模块。 也就是说，如果你加载一个之前已被加载过的模块，那么导入处理器将不会再被触发。 另外，要是你从sys.modules中删除模块然后再重新导入，处理器又会再一次触发。</p>
<p>更多关于导入后钩子信息请参考 <a href="https://www.python.org/dev/peps/pep-0369">PEP 369</a>.</p>
<h2 id="安装私有的包"><a class="header" href="#安装私有的包">安装私有的包</a></h2>
<h3 id="问题-11"><a class="header" href="#问题-11">问题</a></h3>
<p>你想要安装一个第三方包，但是没有权限将它安装到系统Python库中去。 或者，你可能想要安装一个供自己使用的包，而不是系统上面所有用户。</p>
<h3 id="解决方案-11"><a class="header" href="#解决方案-11">解决方案</a></h3>
<p>Python有一个用户安装目录，通常类似”~/.local/lib/python3.3/site-packages”。 要强制在这个目录中安装包，可使用安装选项“–user”。例如：</p>
<pre><code>python3 setup.py install --user
</code></pre>
<p>或者</p>
<pre><code>pip install --user packagename
</code></pre>
<p>在sys.path中用户的“site-packages”目录位于系统的“site-packages”目录之前。 因此，你安装在里面的包就比系统已安装的包优先级高 （尽管并不总是这样，要取决于第三方包管理器，比如distribute或pip）。</p>
<h3 id="讨论-12"><a class="header" href="#讨论-12">讨论</a></h3>
<ul>
<li>通常包会被安装到系统的site-packages目录中去，路径类似“/usr/local/lib/python3.3/site-packages”。</li>
<li>不过，这样做需要有管理员权限并且使用sudo命令。 就算你有这样的权限去执行命令，使用sudo去安装一个新的，可能没有被验证过的包有时候也不安全。</li>
<li>安装包到用户目录中通常是一个有效的方案，它允许你创建一个自定义安装。</li>
</ul>
<p>另外，你还可以创建一个虚拟环境，这个我们在下一节会讲到。</p>
<h2 id="创建新的python环境"><a class="header" href="#创建新的python环境">创建新的Python环境</a></h2>
<h3 id="问题-12"><a class="header" href="#问题-12">问题</a></h3>
<p>你想创建一个新的Python环境，用来安装模块和包。 不过，你不想安装一个新的Python克隆，也不想对系统Python环境产生影响。</p>
<h3 id="解决方案-12"><a class="header" href="#解决方案-12">解决方案</a></h3>
<p>你可以使用 <code>pyvenv</code> 命令创建一个新的“虚拟”环境。 这个命令被安装在Python解释器同一目录，或Windows上面的Scripts目录中。下面是一个例子：</p>
<pre><code>bash % pyvenv Spam
bash %
</code></pre>
<p>传给 <code>pyvenv</code> 命令的名字是将要被创建的目录名。当被创建后，Span目录像下面这样：</p>
<pre><code>bash % cd Spam
bash % ls
bin include lib pyvenv.cfg
bash %
</code></pre>
<p>在bin目录中，你会找到一个可以使用的Python解释器：</p>
<pre><code>bash % Spam/bin/python3
Python 3.3.0 (default, Oct 6 2012, 15:45:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; import sys
&gt;&gt;&gt; pprint(sys.path)
['',
'/usr/local/lib/python33.zip',
'/usr/local/lib/python3.3',
'/usr/local/lib/python3.3/plat-darwin',
'/usr/local/lib/python3.3/lib-dynload',
'/Users/beazley/Spam/lib/python3.3/site-packages']
&gt;&gt;&gt;
</code></pre>
<p>这个解释器的特点就是他的site-packages目录被设置为新创建的环境。 如果你要安装第三方包，它们会被安装在那里，而不是通常系统的site-packages目录。</p>
<h3 id="讨论-13"><a class="header" href="#讨论-13">讨论</a></h3>
<ul>
<li>
<p>创建虚拟环境通常是为了安装和管理第三方包。 正如你在例子中看到的那样，<code>sys.path</code> 变量包含来自于系统Python的目录， 而 site-packages目录已经被重定位到一个新的目录。</p>
</li>
<li>
<p>有了一个新的虚拟环境，下一步就是安装一个包管理器，比如distribute或pip。 但安装这样的工具和包的时候，你需要确保你使用的是虚拟环境的解释器。 它会将包安装到新创建的site-packages目录中去。</p>
</li>
<li>
<p>尽管一个虚拟环境看上去是Python安装的一个复制， 不过它实际上只包含了少量几个文件和一些符号链接。 所有标准库函文件和可执行解释器都来自原来的Python安装。 因此，创建这样的环境是很容易的，并且几乎不会消耗机器资源。</p>
</li>
</ul>
<p>默认情况下，虚拟环境是空的，不包含任何额外的第三方库。如果你想将一个已经安装的包作为虚拟环境的一部分， 可以使用“–system-site-packages”选项来创建虚拟环境，例如：</p>
<pre><code>bash % pyvenv --system-site-packages Spam
bash %
</code></pre>
<p>跟多关于 <code>pyvenv</code> 和虚拟环境的信息可以参考 <a href="https://www.python.org/dev/peps/pep-0405/">PEP 405</a>.</p>
<h2 id="分发包"><a class="header" href="#分发包">分发包</a></h2>
<h3 id="问题-13"><a class="header" href="#问题-13">问题</a></h3>
<p>你已经编写了一个有用的库，想将它分享给其他人。</p>
<h3 id="解决方案-13"><a class="header" href="#解决方案-13">解决方案</a></h3>
<p>如果你想分发你的代码，第一件事就是给它一个唯一的名字，并且清理它的目录结构。 例如，一个典型的函数库包会类似下面这样：</p>
<pre><code class="language-python">projectname/
    README.txt
    Doc/
        documentation.txt
    projectname/
        __init__.py
        foo.py
        bar.py
        utils/
            __init__.py
            spam.py
            grok.py
    examples/
        helloworld.py
        ...
</code></pre>
<p>要让你的包可以发布出去，首先你要编写一个 <code>setup.py</code> ，类似下面这样：</p>
<pre><code class="language-python"># setup.py
from distutils.core import setup

setup(name='projectname',
    version='1.0',
    author='Your Name',
    author_email='you@youraddress.com',
    url='http://www.you.com/projectname',
    packages=['projectname', 'projectname.utils'],
)
</code></pre>
<p>下一步，就是创建一个 <code>MANIFEST.in</code> 文件，列出所有在你的包中需要包含进来的非源码文件：</p>
<pre><code class="language-python"># MANIFEST.in
include *.txt
recursive-include examples *
recursive-include Doc *
</code></pre>
<p>确保 <code>setup.py</code> 和 <code>MANIFEST.in</code> 文件放在你的包的最顶级目录中。 一旦你已经做了这些，你就可以像下面这样执行命令来创建一个源码分发包了：</p>
<pre><code class="language-shell">% bash python3 setup.py sdist
</code></pre>
<p>它会创建一个文件比如”projectname-1.0.zip” 或 “projectname-1.0.tar.gz”, 具体依赖于你的系统平台。如果一切正常， 这个文件就可以发送给别人使用或者上传至 <a href="http://pypi.python.org/">Python Package Index</a>.</p>
<h3 id="讨论-14"><a class="header" href="#讨论-14">讨论</a></h3>
<ul>
<li>
<p>对于纯Python代码，编写一个普通的 <code>setup.py</code> 文件通常很简单。 一个可能的问题是你必须手动列出所有构成包源码的子目录。 一个常见错误就是仅仅只列出一个包的最顶级目录，忘记了包含包的子组件。 </p>
</li>
<li>
<p>这也是为什么在 <code>setup.py</code> 中对于包的说明包含了列表 <code>packages=['projectname', 'projectname.utils']</code></p>
</li>
</ul>
<p>大部分Python程序员都知道，有很多第三方包管理器供选择，包括setuptools、distribute等等。 有些是为了替代标准库中的distutils。</p>
<p>注意如果你依赖这些包， 用户可能不能安装你的软件，除非他们已经事先安装过所需要的包管理器。 正因如此，你更应该时刻记住越简单越好的道理。 </p>
<p>最好让你的代码使用标准的Python 3安装。 如果其他包也需要的话，可以通过一个可选项来支持。</p>
<p>对于涉及到C扩展的代码打包与分发就更复杂点了。 第15章对关于C扩展的这方面知识有一些详细讲解，特别是在15.2小节中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-with语句"><a class="header" href="#python-with语句">Python with语句</a></h1>
<p><code>with</code>语句究竟有哪些好处？</p>
<p>它有助于简化一些通用资源管理模式，抽象出其中的功能，将其分解并重用。</p>
<pre><code class="language-python">with open('hello.txt', 'w') as f:
    f.write('hello, world!')
</code></pre>
<pre><code class="language-python">f = open('hello.txt', 'w')
try:
    f.write('hello, world')
finally:
    f.close()
</code></pre>
<p><code>threading.Lock</code>类是Python标准库中另一个比较好的示例，它有效地使用了<code>with</code>语句：</p>
<pre><code class="language-python">some_lock = threading.Lock()

# 有问题:
some_lock.acquire()
try:
    # 执行某些操作……
finally:
    some_lock.release()

# 改进版:
with some_lock:
    # 执行某些操作……

</code></pre>
<p>在这两个例子中，使用<code>with</code>语句都可以抽象出大部分资源处理逻辑。不必每次都显式地写一个<code>try...finally</code>语句，<code>with</code>语句会自行处理。</p>
<p><code>with</code>语句不仅让处理系统资源的代码更易读，而且由于绝对不会忘记清理或释放资源，因此还可以避免bug或资源泄漏。</p>
<h2 id="python-with语句-在自定义对象中支持with"><a class="header" href="#python-with语句-在自定义对象中支持with">Python with语句 在自定义对象中支持<code>with</code></a></h2>
<p>无论是<code>open()</code>函数和<code>threading.Lock</code>类本身，还是它们与<code>with</code>语句一起使用，这些都没有什么特殊之处。只要实现所谓的<strong>上下文管理器</strong>（context manager），就可以在自定义的类和函数中获得相同的功能。</p>
<p>详见Python文档: “With Statement Context Managers”。</p>
<p>上下文管理器是什么？这是一个简单的“协议”（或接口），自定义对象需要遵循这个接口来支持<code>with</code>语句。</p>
<p>总的来说，如果想将一个对象作为上下文管理器，需要做的就是向其中添加<code>__enter__</code>和<code>__exit__</code>方法。</p>
<pre><code>class ManagedFile:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        self.file = open(self.name, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
Python

</code></pre>
<p>其中的<code>ManagedFile</code>类遵循上下文管理器协议，所以与原来的<code>open()</code>例子一样，也支持<code>with</code>语句：</p>
<pre><code>&gt;&gt;&gt; with ManagedFile('hello.txt') as f:
f.write('hello, world!')
f.write('bye now')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="切换数据源"><a class="header" href="#切换数据源">切换数据源</a></h3>
<pre><code>国内镜像源：
清华：https://pypi.tuna.tsinghua.edu.cn/simple

阿里云：http://mirrors.aliyun.com/pypi/simple/

中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/

华中理工大学：http://pypi.hustunique.com/

山东理工大学：http://pypi.sdutlinux.org/

豆瓣：http://pypi.douban.com/simple/
</code></pre>
<pre><code>pip3 install -i https://pypi.doubanio.com/simple/ 包名
</code></pre>
<pre><code>~/.pip/pip.conf

[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host=mirrors.aliyun.com
</code></pre>
<pre><code>windows下，直接在 %userprofile% 目录中创建一个 pip目录，再新建文件 pip.ini。（例如：C:\Users\WQP\pip\pip.ini）内容同上。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="关于导入"><a class="header" href="#关于导入">关于导入</a></h2>
<p>Fabric由几个库组成，提供统一的接口层</p>
<p>用户代码 可以从 fabric中导入包。也可以直接从 <em>invoke</em> <em>paramiko</em> 库中导入</p>
<ul>
<li><a href="https://www.pyinvoke.org/">Invoke</a> 实现命令行参数解析,组织任务，shell命令执行 (一个通用框架，且实现了本地命令执行.)
<ul>
<li>Anything that isn’t specific to remote systems tends to live in Invoke, and it is often used standalone by programmers who don’t need any remote functionality.</li>
<li>Fabric users will frequently import Invoke objects, in cases where Fabric itself has no need to subclass or otherwise modify what Invoke provides.</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://www.paramiko.org/">Paramiko</a> implements low/mid level SSH functionality - SSH and SFTP sessions, key management, etc.
<ul>
<li>Fabric mostly uses this under the hood; users will only rarely import from Paramiko directly.</li>
</ul>
</li>
<li>Fabric将其他 库 粘合起来 提供 高层的抽象
<ul>
<li>Subclassing Invoke’s context and command-runner classes, wrapping them around Paramiko-level primitives;</li>
<li>Extending Invoke’s configuration system by using Paramiko’s <code>ssh_config</code> parsing machinery;</li>
<li>Implementing new high-level primitives of its own, such as port-forwarding context managers. (These may, in time, migrate downwards into Paramiko.)</li>
</ul>
</li>
</ul>
<h2 id="run-commands-via-connections-and-run"><a class="header" href="#run-commands-via-connections-and-run">Run commands via Connections and <code>run</code></a></h2>
<p>Fabric 最基本的用途是通过 SSH 在远程系统上执行 shell 命令，然后（可选）询问结果。默认情况下，远程程序的输出直接打印到终端并捕获。一个基本示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from fabric import Connection
&gt;&gt;&gt; c = Connection('web1')
&gt;&gt;&gt; result = c.run('uname -s')
Linux
&gt;&gt;&gt; result.stdout.strip() == 'Linux'
True
&gt;&gt;&gt; result.exited
0
&gt;&gt;&gt; result.ok
True
&gt;&gt;&gt; result.command
'uname -s'
&gt;&gt;&gt; result.connection
&lt;Connection host=web1&gt;
&gt;&gt;&gt; result.connection.host
'web1'
</code></pre>
<pre><code class="language-shell">Connection(host='web1', user='deploy', port=2202)

Connection('deploy@web1:2202')
</code></pre>
<p><em>Connection</em> 对象的run方法通常返回  <code>invoke.runners.Result</code> 或其子类</p>
<p><strong>注意</strong>：Many lower-level SSH connection arguments (such as private keys and timeouts) can be given directly to the SSH backend by using the <a href="https://docs.fabfile.org/en/2.6/api/connection.html#connect-kwargs-arg">connect_kwargs argument</a>.</p>
<h2 id="superuser-privileges-via-auto-response"><a class="header" href="#superuser-privileges-via-auto-response">Superuser privileges via auto-response</a></h2>
<blockquote>
<p>超级管理员</p>
</blockquote>
<p>需要以远程系统的超级用户身份运行操作？您可以通过运行调用 sudo 程序，并且（如果您的远程系统未配置无密码 sudo）手动响应密码提示，如下所示。（请注意我们需要如何请求远程伪终端;否则，大多数 sudo 实现在密码提示时会变得脾气暴躁。)</p>
<pre><code class="language-python">&gt;&gt;&gt; from fabric import Connection
&gt;&gt;&gt; c = Connection('db1')
&gt;&gt;&gt; c.run('sudo useradd mydbuser', pty=True)
[sudo] password:
&lt;Result cmd='sudo useradd mydbuser' exited=0&gt;
&gt;&gt;&gt; c.run('id -u mydbuser')
1001
&lt;Result cmd='id -u mydbuser' exited=0&gt;
</code></pre>
<p>每次手动提供密码已经过时了</p>
<p>值得庆幸的是，Invoke强大的命令执行功能包括使用预定义输入自动响应程序输出的功能。</p>
<p>我们可以将其用于sudo：</p>
<pre><code class="language-python">&gt;&gt;&gt; from invoke import Responder
&gt;&gt;&gt; from fabric import Connection
&gt;&gt;&gt; c = Connection('host')
&gt;&gt;&gt; sudopass = Responder(
...     pattern=r'\[sudo\] password:',
...     response='mypassword\n',
... )
&gt;&gt;&gt; c.run('sudo whoami', pty=True, watchers=[sudopass])
[sudo] password:
root
&lt;Result cmd='sudo whoami' exited=0&gt;
</code></pre>
<h3 id="the-sudo-helper"><a class="header" href="#the-sudo-helper">The <code>sudo</code> helper</a></h3>
<p>使用观察器/响应程序在这里效果很好，但每次都需要设置很多样板 - 特别是因为实际用例需要更多的工作来检测失败/不正确的密码。</p>
<p>Invoke提供了一个Context.sudo方法</p>
<p>用户需要做的就是确保填写 sudo.password 配置值（通过配置文件、环境变量或 --prompt-for-sudo-password），然后 Connection.sudo 处理其余部分。为清楚起见，下面是一个示例，其中库/shell 用户执行自己的基于 getpass 的密码提示：</p>
<pre><code class="language-python">&gt;&gt;&gt; import getpass
&gt;&gt;&gt; from fabric import Connection, Config
&gt;&gt;&gt; sudo_pass = getpass.getpass(&quot;What's your sudo password?&quot;)
What's your sudo password?
&gt;&gt;&gt; config = Config(overrides={'sudo': {'password': sudo_pass}})
&gt;&gt;&gt; c = Connection('db1', config=config)
&gt;&gt;&gt; c.sudo('whoami', hide='stderr')
root
&lt;Result cmd=&quot;...whoami&quot; exited=0&gt;
&gt;&gt;&gt; c.sudo('useradd mydbuser')
&lt;Result cmd=&quot;...useradd mydbuser&quot; exited=0&gt;
&gt;&gt;&gt; c.run('id -u mydbuser')
1001
&lt;Result cmd='id -u mydbuser' exited=0&gt;
</code></pre>
<h2 id="transfer-files"><a class="header" href="#transfer-files">Transfer files</a></h2>
<p>除了 shell 命令执行之外，SSH 连接的另一个常见用途是文件传输;Connection.put 和 Connection.get exist 可以满足这一需求。例如，假设您有一个要上传的归档文件：</p>
<pre><code class="language-python">&gt;&gt;&gt; from fabric import Connection
&gt;&gt;&gt; result = Connection('web1').put('myfiles.tgz', remote='/opt/mydata/')
&gt;&gt;&gt; print(&quot;Uploaded {0.local} to {0.remote}&quot;.format(result))
Uploaded /local/myfiles.tgz to /opt/mydata/
</code></pre>
<p>这些方法通常在参数评估方面遵循 cp 和 scp/sftp 的行为 - 例如，在上面的代码片段中，我们省略了远程路径参数的文件名部分。</p>
<h2 id="multiple-actions"><a class="header" href="#multiple-actions">Multiple actions</a></h2>
<p>单行线是很好的例子，但并不总是现实的用例 - 通常需要多个步骤来做任何有趣的事情。在最基本的级别上，您可以通过多次调用 Connection 方法来执行此操作：</p>
<pre><code class="language-python">from fabric import Connection
c = Connection('web1')
c.put('myfiles.tgz', '/opt/mydata')
c.run('tar -C /opt/mydata -xzvf /opt/mydata/myfiles.tgz')
</code></pre>
<p>您可以（但不必）将此类代码块转换为函数，并使用调用方的 Connection 对象进行参数化，以鼓励重用：</p>
<pre><code class="language-python">def upload_and_unpack(c):
    c.put('myfiles.tgz', '/opt/mydata')
    c.run('tar -C /opt/mydata -xzvf /opt/mydata/myfiles.tgz')
</code></pre>
<p>正如您将在下面看到的，这些函数可以交给其他API方法，以实现更复杂的用例。</p>
<h2 id="multiple-servers"><a class="header" href="#multiple-servers">Multiple servers</a></h2>
<p>大多数实际用例都涉及在多个服务器上执行操作。简单的方法可以循环访问连接参数的列表或元组（或连接对象本身，也许通过map）：</p>
<pre><code class="language-python">&gt;&gt;&gt; from fabric import Connection
&gt;&gt;&gt; for host in ('web1', 'web2', 'mac1'):
...     result = Connection(host).run('uname -s')
...     print(&quot;{}: {}&quot;.format(host, result.stdout.strip()))
...
...
web1: Linux
web2: Linux
mac1: Darwin
</code></pre>
<p>这种方法是有效的，但随着用例变得越来越复杂，将主机集合视为单个对象会很有用。</p>
<p>输入 Group，这是一个包装一个或多个连接对象并提供类似 API 的类;</p>
<p>具体来说，您将需要使用其具体的子类之一，如 SerialGroup 或 ThreadingGroup。</p>
<p>The previous example, using <a href="https://docs.fabfile.org/en/2.6/api/group.html#fabric.group.Group"><code>Group</code></a> (<a href="https://docs.fabfile.org/en/2.6/api/group.html#fabric.group.SerialGroup"><code>SerialGroup</code></a> specifically), looks like this:</p>
<pre><code class="language-python">&gt;&gt;&gt; from fabric import SerialGroup as Group
&gt;&gt;&gt; results = Group('web1', 'web2', 'mac1').run('uname -s')
&gt;&gt;&gt; print(results)
&lt;GroupResult: {
    &lt;Connection 'web1'&gt;: &lt;CommandResult 'uname -s'&gt;,
    &lt;Connection 'web2'&gt;: &lt;CommandResult 'uname -s'&gt;,
    &lt;Connection 'mac1'&gt;: &lt;CommandResult 'uname -s'&gt;,
}&gt;
&gt;&gt;&gt; for connection, result in results.items():
...     print(&quot;{0.host}: {1.stdout}&quot;.format(connection, result))
...
...
web1: Linux
web2: Linux
mac1: Darwin
</code></pre>
<p>如果连接方法返回单个 Result 对象（例如 fabric.runners.Result），则 Group 方法返回 GroupResult -类似 dict 的对象，提供对单个每个连接结果的访问权限以及有关整个运行的元数据。</p>
<p>当组内的任何单个连接遇到错误时，GroupResult 会略微包装在组异常中，该异常将引发。因此，聚合行为类似于各个 Connection 方法的行为，在成功时返回值或在失败时引发异常。</p>
<h2 id="bringing-it-all-together"><a class="header" href="#bringing-it-all-together">Bringing it all together</a></h2>
<p>最后，我们得出了最实际的用例：您有一堆命令和/或文件传输，并且希望将其应用于多个服务器。您可以使用多个 Group 方法调用来执行此操作：</p>
<pre><code class="language-python">from fabric import SerialGroup as Group
pool = Group('web1', 'web2', 'web3')
pool.put('myfiles.tgz', '/opt/mydata')
pool.run('tar -C /opt/mydata -xzvf /opt/mydata/myfiles.tgz')
</code></pre>
<p>一旦逻辑变得必要，这种方法就会失效 - 例如，如果您只想在 /opt/mydata 为空时执行上面的 copy-and-untar。执行此类检查需要基于每个服务器执行。</p>
<p>您可以通过使用连接对象的可迭代对象来满足该需求（尽管这放弃了使用组的一些好处）：</p>
<pre><code class="language-python">from fabric import Connection
for host in ('web1', 'web2', 'web3'):
    c = Connection(host)
    if c.run('test -f /opt/mydata/myfile', warn=True).failed:
        c.put('myfiles.tgz', '/opt/mydata')
        c.run('tar -C /opt/mydata -xzvf /opt/mydata/myfiles.tgz')
</code></pre>
<p>或者，还记得我们在前面的示例中如何使用函数吗？您可以改为走这条路：</p>
<pre><code class="language-python">from fabric import SerialGroup as Group

def upload_and_unpack(c):
    if c.run('test -f /opt/mydata/myfile', warn=True).failed:
        c.put('myfiles.tgz', '/opt/mydata')
        c.run('tar -C /opt/mydata -xzvf /opt/mydata/myfiles.tgz')

for connection in Group('web1', 'web2', 'web3'):
    upload_and_unpack(connection)
</code></pre>
<p>最后一种方法缺乏的唯一便利性是 Group.run 的有用类似物 - 如果要将所有upload_and_unpack调用的结果作为聚合进行跟踪，则必须自己执行此操作。期待未来的功能版本，以获取有关此领域的更多内容！</p>
<h2 id="addendum-the-fab-command-line-tool"><a class="header" href="#addendum-the-fab-command-line-tool">Addendum: the <code>fab</code> command-line tool</a></h2>
<blockquote>
<p>附录：</p>
</blockquote>
<p>从 shell 运行 Fabric 代码通常很有用，例如，在任意服务器上部署应用程序或运行 sysadmin 作业。您可以使用带有Fabric库代码的常规Invine任务，但另一个选项是Fabric自己的&quot;面向网络&quot;工具fab。</p>
<p>fab 将 Invoke 的 CLI 机制与主机选择等功能相结合，让您在各种服务器上快速运行任务 - 无需在所有任务或类似任务上定义主机 kwargs。</p>
<p>对于最后一个代码示例，让我们将前面的示例改编为一个名为 fabfile.py 的 fab 任务模块：</p>
<pre><code class="language-python">from fabric import task

@task
def upload_and_unpack(c):
    if c.run('test -f /opt/mydata/myfile', warn=True).failed:
        c.put('myfiles.tgz', '/opt/mydata')
        c.run('tar -C /opt/mydata -xzvf /opt/mydata/myfiles.tgz')
</code></pre>
<p>这并不难 - 我们所做的只是将临时任务函数复制到一个文件中，并在其上打上装饰器。任务告诉 CLI 机器在命令行上公开任务：</p>
<pre><code class="language-python">$ fab --list
Available tasks:

  upload_and_unpack
</code></pre>
<p>然后，当fab实际调用任务时，它知道如何将控制目标服务器的参数拼接在一起，并在每个服务器上运行一次任务。在单个服务器上运行一次任务：</p>
<pre><code class="language-shell">发生这种情况时，任务内部的 c 将有效地设置为 Connection（&quot;web1&quot;） - 如前面的示例所示。同样，您可以为多个主机提供多个主机，该主机多次运行任务，每次都交出不同的连接实例：


fab -H web1 upload_and_unpack
</code></pre>
<pre><code>$ fab -H web1,web2,web3 upload_and_unpack
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Invoke提供了一种多方面的配置机制，允许您通过配置文件、环境变量、任务名称空间和CLI标志的层次结构来配置核心行为和任务的行为。</p>
<p>配置搜索，加载，解析和合并的最终结果是一个Config对象，它的行为就像一个 (嵌套的) Python字典。Invoke在运行时引用此对象 (确定诸如Context.run之类的方法的默认行为)，并将其作为Context.config或 Context 本身的速记属性访问方式公开给用户的任务。</p>
<h2 id="the-configuration-hierarchy"><a class="header" href="#the-configuration-hierarchy">The configuration hierarchy</a></h2>
<p>简而言之，配置值相互覆盖的顺序如下:</p>
<ol>
<li>
<p><strong>Internal default values</strong> ：默认值</p>
</li>
<li>
<p><strong>Collection-driven configurations</strong>   通过 <a href="https://docs.pyinvoke.org/en/latest/api/collection.html#invoke.collection.Collection.configure"><code>Collection.configure</code></a> 定义，Sub-collections的配置被合并到顶级集合中，最终结果构成了整个配置设置的基础。</p>
</li>
<li>
<p><strong>System-level configuration file</strong> stored in <code>/etc/</code>, such as <code>/etc/invoke.yaml</code></p>
</li>
<li>
<p><strong>User-level configuration file</strong> found in the running user’s home directory, e.g. <code>~/.invoke.yaml</code>.</p>
</li>
<li>
<p><strong>Project-level configuration file</strong> living next to your top level <code>tasks.py</code>. For example, if your run of Invoke loads <code>/home/user/myproject/tasks.py</code> (see our docs on <a href="https://docs.pyinvoke.org/en/latest/concepts/loading.html">the load process</a>), this might be <code>/home/user/myproject/invoke.yaml</code>.</p>
</li>
<li>
<p><strong>Environment variables</strong> found in the invoking shell environment.</p>
<blockquote>
<ul>
<li>These aren’t as strongly hierarchical as the rest, nor is the shell environment namespace owned wholly by Invoke, so we must rely on slightly verbose prefixing instead - see <a href="https://docs.pyinvoke.org/en/latest/concepts/configuration.html#env-vars">Environment variables</a> for details.</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>Runtime configuration file</strong> whose path is given to <a href="https://docs.pyinvoke.org/en/latest/invoke.html#cmdoption-f"><code>-f</code></a>, e.g. <code>inv -f /random/path/to/config_file.yaml</code>. This path may also be set via the <code>INVOKE_RUNTIME_CONFIG</code> env var.</p>
</li>
<li>
<p><strong>Command-line flags</strong> for certain core settings, such as <a href="https://docs.pyinvoke.org/en/latest/invoke.html#cmdoption-e"><code>-e</code></a>.</p>
</li>
<li>
<p><strong>Modifications made by user code</strong> at runtime.</p>
</li>
</ol>
<h2 id="default-configuration-values"><a class="header" href="#default-configuration-values">Default configuration values</a></h2>
<p>下面列出了所有配置值和/或section Invoke本身用于控制行为的列表，例如Context.run的echo和pty标志，任务重复数据删除等。</p>
<p>这些值的存储位置在Config类内部，特别是Config.global_defaults的返回值; 有关更多详细信息，请参见其API文档。</p>
<p>For convenience, we refer to nested setting names with a dotted syntax, so e.g. <code>foo.bar</code> refers to what would be (in a Python config context) <code>{'foo': {'bar': &lt;value here&gt;}}</code>. Typically, these can be read or set on <a href="https://docs.pyinvoke.org/en/latest/api/config.html#invoke.config.Config"><code>Config</code></a> and <a href="https://docs.pyinvoke.org/en/latest/api/context.html#invoke.context.Context"><code>Context</code></a> objects using attribute syntax, which looks nearly identical: <code>c.foo.bar</code>.</p>
<p>为了方便起见，我们引用带有点语法的嵌套设置名称，例如foo.bar指的是 (在Python config上下文中) <code>{'foo': {'bar': &lt;value here &gt;}}</code>。通常，可以使用属性语法在Config和Context对象上读取或设置这些语法，这些语法看起来几乎相同: c.foo.bar。</p>
<p>任务配置树保存与任务执行相关的设置。</p>
<ul>
<li>
<p><code>tasks.dedupe</code> controls <a href="https://docs.pyinvoke.org/en/latest/concepts/invoking-tasks.html#deduping">Task deduplication</a> and defaults to <code>True</code>. It can also be overridden at runtime via <a href="https://docs.pyinvoke.org/en/latest/invoke.html#cmdoption-no-dedupe"><code>--no-dedupe</code></a>.</p>
</li>
<li>
<p><code>tasks.auto_dash_names</code> 控制任务名称和集合名称是否已将下划线转到CLI上的破折号。 Default: <code>True</code>. See also <a href="https://docs.pyinvoke.org/en/latest/concepts/namespaces.html#dashes-vs-underscores">Dashes vs underscores</a>.</p>
</li>
<li>
<p><code>tasks.collection_name</code> controls the Python import name sought out by <a href="https://docs.pyinvoke.org/en/latest/concepts/loading.html#collection-discovery">collection discovery</a>, and defaults to <code>&quot;tasks&quot;</code>.</p>
</li>
<li>
<p><code>tasks.executor_class</code> allows users to override the class instantiated and used for task execution.</p>
</li>
</ul>
<p>Must be a fully-qualified dotted path of the form <code>module(.submodule...).class</code>, where all but <code>.class</code> will be handed to <a href="https://docs.python.org/2.7/library/importlib.html#importlib.import_module"><code>importlib.import_module</code></a>, and <code>class</code> is expected to be an attribute on that resulting module object.</p>
<p>Defaults to <code>None</code>, meaning to use the running <a href="https://docs.pyinvoke.org/en/latest/api/program.html#invoke.program.Program"><code>Program</code></a> object’s <code>executor_class</code> attribute.</p>
<p>Warning</p>
<p>Take care if using this setting in tandem with <a href="https://docs.pyinvoke.org/en/latest/concepts/library.html#reusing-as-a-binary">custom program binaries</a>, since custom programs may specify their own default executor class (which your use of this setting will override!) and assume certain behaviors stemming from that.</p>
<p><code>tasks.search_root</code> allows overriding the default <a href="https://docs.pyinvoke.org/en/latest/concepts/loading.html#collection-discovery">collection discovery</a> root search location. It defaults to <code>None</code>, which indicates to use the executing process’ current working directory.</p>
<ul>
<li>
<p>The <code>run</code> tree controls the behavior of <a href="https://docs.pyinvoke.org/en/latest/api/runners.html#invoke.runners.Runner.run"><code>Runner.run</code></a>. Each member of this tree (such as <code>run.echo</code> or <code>run.pty</code>) maps directly to a <a href="https://docs.pyinvoke.org/en/latest/api/runners.html#invoke.runners.Runner.run"><code>Runner.run</code></a> keyword argument of the same name; see that method’s docstring for details on what these settings do &amp; what their default values are.</p>
</li>
<li>
<p>• 运行 • 树控制 • Runner.ru n • 的行为。此树的每个成员 (例如 • run.echo • 或 • run.pt y •) 直接映射到具有相同名称的 • Runner.ru n • 关键字参数; 有关这些设置的功能和默认值的详细信息，请参阅该方法的docstring。</p>
</li>
<li>
<p>The <code>runners</code> tree controls <em>which</em> runner classes map to which execution contexts; if you’re using Invoke by itself, this will only tend to have a single member, <code>runners.local</code>. Client libraries may extend it with additional key/value pairs, such as <code>runners.remote</code>.</p>
</li>
<li>
<p>The <code>sudo</code> tree controls the behavior of <a href="https://docs.pyinvoke.org/en/latest/api/context.html#invoke.context.Context.sudo"><code>Context.sudo</code></a>:</p>
<blockquote>
<ul>
<li>
<p><code>sudo.password</code> controls the autoresponse password submitted to sudo’s password prompt. Default: <code>None</code>.</p>
<p>Warning</p>
<p>While it’s possible to store this setting, like any other, in <a href="https://docs.pyinvoke.org/en/latest/concepts/configuration.html#">configuration files</a> – doing so is inherently insecure. We highly recommend filling this config value in at runtime from a secrets management system of some kind.</p>
</li>
<li>
<p><code>sudo.prompt</code> holds the sudo password prompt text, which is both supplied to <code>sudo -p</code>, and searched for when performing <a href="https://docs.pyinvoke.org/en/latest/concepts/watchers.html">auto-response</a>. Default: <code>[sudo] password:</code>.</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>A top level config setting, <code>debug</code>, controls whether debug-level output is logged; it defaults to <code>False</code>.</p>
<p><code>debug</code> can be toggled via the <a href="https://docs.pyinvoke.org/en/latest/invoke.html#cmdoption-d"><code>-d</code></a> CLI flag, which enables debugging after CLI parsing runs. It can also be toggled via the <code>INVOKE_DEBUG</code> environment variable which - unlike regular env vars - is honored from the start of execution and is thus useful for troubleshooting parsing and/or config loading.</p>
</li>
<li>
<p>A small config tree, <code>timeouts</code>, holds various kinds of timeout controls. At present, for Invoke, this only holds a <code>command</code> subkey, which controls subprocess execution timeouts.</p>
<blockquote>
<ul>
<li>Client code often adds more to this tree, and Invoke itself may add more in the future as well.</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration files</a></h2>
<h3 id="loading"><a class="header" href="#loading">Loading</a></h3>
<p>For each configuration file location mentioned in the previous section, we search for files ending in <code>.yaml</code>, <code>.yml</code>, <code>.json</code> or <code>.py</code> (<strong>in that order!</strong>), load the first one we find, and ignore any others that might exist.</p>
<p>For example, if Invoke is run on a system containing both <code>/etc/invoke.yml</code> <em>and</em> <code>/etc/invoke.json</code>, <strong>only the YAML file will be loaded</strong>. This helps keep things simple, both conceptually and in the implementation.</p>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<p>Invoke’s configuration allows arbitrary nesting, and thus so do our config file formats. All three of the below examples result in a configuration equivalent to <code>{'debug': True, 'run': {'echo': True}}</code>:</p>
<ul>
<li>
<p><strong>YAML</strong></p>
<pre><code>debug: true
run:
    echo: true
</code></pre>
</li>
<li>
<p><strong>JSON</strong></p>
<pre><code>{
    &quot;debug&quot;: true,
    &quot;run&quot;: {
        &quot;echo&quot;: true
    }
}
</code></pre>
</li>
<li>
<p><strong>Python</strong>:</p>
<pre><code>debug = True
run = {
    &quot;echo&quot;: True
}
</code></pre>
</li>
</ul>
<p>For further details, see these languages’ own documentation.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>Environment variables are a bit different from other configuration-setting methods, since they don’t provide a clean way to nest configuration keys, and are also implicitly shared amongst the entire system’s installed application base.</p>
<p>In addition, due to implementation concerns, env vars must be pre-determined by the levels below them in the config hierarchy (in other words - env vars may only be used to override existing config values). If you need Invoke to understand a <code>FOOBAR</code> environment variable, you must first declare a <code>foobar</code> setting in a configuration file or in your task collections.</p>
<h3 id="basic-rules"><a class="header" href="#basic-rules">Basic rules</a></h3>
<p>To mitigate the shell namespace problem, we simply prefix all our env vars with <code>INVOKE_</code>.</p>
<p>Nesting is performed via underscore separation, so a setting that looks like e.g. <code>{'run': {'echo': True}}</code> at the Python level becomes <code>INVOKE_RUN_ECHO=1</code> in a typical shell. See <a href="https://docs.pyinvoke.org/en/latest/concepts/configuration.html#env-var-nesting">Nesting vs underscored names</a> below for more on this.</p>
<h3 id="type-casting"><a class="header" href="#type-casting">Type casting</a></h3>
<p>Since env vars can only be used to override existing settings, the previous value of a given setting is used as a guide in casting the strings we get back from the shell:</p>
<ul>
<li>
<p>If the current value is a string or Unicode object, it is replaced with the value from the environment, with no casting whatsoever;</p>
<blockquote>
<ul>
<li>Depending on interpreter and environment, this means that a setting defaulting to a non-Unicode string type (eg a <code>str</code> on Python 2) may end up replaced with a Unicode string, or vice versa. This is intentional as it prevents users from accidentally limiting themselves to non-Unicode strings.</li>
</ul>
</blockquote>
</li>
<li>
<p>If the current value is <code>None</code>, it too is replaced with the string from the environment;</p>
</li>
<li>
<p>Booleans are set as follows: <code>0</code> and the empty value/string (e.g. <code>SETTING=</code>, or <code>unset SETTING</code>, or etc) evaluate to <code>False</code>, and any other value evaluates to <code>True</code>.</p>
</li>
<li>
<p>Lists and tuples are currently unsupported and will raise an exception;</p>
<blockquote>
<ul>
<li>In the future we may implement convenience transformations, such as splitting on commas to form a list; however since users can always perform such operations themselves, it may not be a high priority.</li>
</ul>
</blockquote>
</li>
<li>
<p>All other types - integers, longs, floats, etc - are simply used as constructors for the incoming value.</p>
<blockquote>
<ul>
<li>For example, a <code>foobar</code> setting whose default value is the integer <code>1</code> will run all env var inputs through <a href="https://docs.python.org/2.7/library/functions.html#int"><code>int</code></a>, and thus <code>FOOBAR=5</code> will result in the Python value <code>5</code>, not <code>&quot;5&quot;</code>.</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="nesting-vs-underscored-names"><a class="header" href="#nesting-vs-underscored-names">Nesting vs underscored names</a></h3>
<p>Since environment variable keys are single strings, we must use some form of string parsing to allow access to nested configuration settings. As mentioned above, in basic use cases this just means using an underscore character: <code>{'run': {'echo': True}}</code> becomes <code>INVOKE_RUN_ECHO=1</code>.</p>
<p>However, ambiguity is introduced when the settings names themselves contain underscores: is <code>INVOKE_FOO_BAR=baz</code> equivalent to <code>{'foo': {'bar': 'baz'}}</code>, or to <code>{'foo_bar': 'baz'}</code>? Thankfully, because env vars can only be used to modify settings declared at the Python level or in config files, we look at the current state of the config to determine the answer.</p>
<p>There is still a corner case where <em>both</em> possible interpretations exist as valid config paths (e.g. <code>{'foo': {'bar': 'default'}, 'foo_bar': 'otherdefault'}</code>). In this situation, we honor the <a href="http://zen-of-python.info/in-the-face-of-ambiguity-refuse-the-temptation-to-guess.html#12">Zen of Python</a> and refuse to guess; an error is raised instead, counseling users to modify their configuration layout or avoid using env vars for the setting in question.</p>
<h2 id="collection-based-configuration"><a class="header" href="#collection-based-configuration"><a href="https://docs.pyinvoke.org/en/latest/api/collection.html#invoke.collection.Collection"><code>Collection</code></a>-based configuration</a></h2>
<p><a href="https://docs.pyinvoke.org/en/latest/api/collection.html#invoke.collection.Collection"><code>Collection</code></a> objects may contain a config mapping, set via <a href="https://docs.pyinvoke.org/en/latest/api/collection.html#invoke.collection.Collection.configure"><code>Collection.configure</code></a>, and (as per <a href="https://docs.pyinvoke.org/en/latest/concepts/configuration.html#config-hierarchy">the hierarchy</a>) this typically forms the lowest level of configuration in the system.</p>
<p>When collections are <a href="https://docs.pyinvoke.org/en/latest/concepts/namespaces.html">nested</a>, configuration is merged ‘downwards’ by default: when conflicts arise, outer namespaces closer to the root will win, versus inner ones closer to the task being invoked.</p>
<p>Note</p>
<p>‘Inner’ tasks here are specifically those on the path from the root to the one housing the invoked task. ‘Sibling’ subcollections are ignored.</p>
<p>A quick example of what this means:</p>
<pre><code>from invoke import Collection, task

# This task &amp; collection could just as easily come from
# another module somewhere.
@task
def mytask(c):
    print(c['conflicted'])
inner = Collection('inner', mytask)
inner.configure({'conflicted': 'default value'})

# Our project's root namespace.
ns = Collection(inner)
ns.configure({'conflicted': 'override value'})
</code></pre>
<p>The result of calling <code>inner.mytask</code>:</p>
<pre><code>$ inv inner.mytask
override value
</code></pre>
<h2 id="example-of-real-world-config-use"><a class="header" href="#example-of-real-world-config-use">Example of real-world config use</a></h2>
<p>The previous sections had small examples within them; this section provides a more realistic-looking set of examples showing how the config system works.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>We’ll start out with semi-realistic tasks that hardcode their values, and build up to using the various configuration mechanisms. A small module for building <a href="http://sphinx-doc.org/">Sphinx</a> docs might begin like this:</p>
<pre><code>from invoke import task

@task
def clean(c):
    c.run(&quot;rm -rf docs/_build&quot;)

@task
def build(c):
    c.run(&quot;sphinx-build docs docs/_build&quot;)
</code></pre>
<p>Then maybe you refactor the build target:</p>
<pre><code>target = &quot;docs/_build&quot;

@task
def clean(c):
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c):
    c.run(&quot;sphinx-build docs {}&quot;.format(target))
</code></pre>
<p>We can also allow runtime parameterization:</p>
<pre><code>default_target = &quot;docs/_build&quot;

@task
def clean(c, target=default_target):
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c, target=default_target):
    c.run(&quot;sphinx-build docs {}&quot;.format(target))
</code></pre>
<p>This task module works for a single set of users, but what if we want to allow reuse? Somebody may want to use this module with a different default target. Using the configuration data (made available via the context arg) to configure these settings is usually the better solution [<a href="https://docs.pyinvoke.org/en/latest/concepts/configuration.html#id3">1]</a>.</p>
<h3 id="configuring-via-task-collection"><a class="header" href="#configuring-via-task-collection">Configuring via task collection</a></h3>
<p>The configuration <a href="https://docs.pyinvoke.org/en/latest/api/collection.html#invoke.collection.Collection.configure"><code>setting</code></a> and <a href="https://docs.pyinvoke.org/en/latest/api/context.html#invoke.context.Context.config"><code>getting</code></a> APIs enable moving otherwise ‘hardcoded’ default values into a config structure which downstream users are free to redefine. Let’s apply this to our example. First we add an explicit namespace object:</p>
<pre><code>from invoke import Collection, task

default_target = &quot;docs/_build&quot;

@task
def clean(c, target=default_target):
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c, target=default_target):
    c.run(&quot;sphinx-build docs {}&quot;.format(target))

ns = Collection(clean, build)
</code></pre>
<p>Then we can move the default build target value into the collection’s default configuration, and refer to it via the context. At this point we also change our kwarg default value to be <code>None</code> so we can determine whether or not a runtime value was given. The result:</p>
<pre><code>@task
def clean(c, target=None):
    if target is None:
        target = c.sphinx.target
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c, target=None):
    if target is None:
        target = c.sphinx.target
    c.run(&quot;sphinx-build docs {}&quot;.format(target))

ns = Collection(clean, build)
ns.configure({'sphinx': {'target': &quot;docs/_build&quot;}})
</code></pre>
<p>The result isn’t significantly more complex than what we began with, and as we’ll see next, it’s now trivial for users to override your defaults in various ways.</p>
<h3 id="configuration-overriding"><a class="header" href="#configuration-overriding">Configuration overriding</a></h3>
<p>The lowest-level override is, of course, just modifying the local <a href="https://docs.pyinvoke.org/en/latest/api/collection.html#invoke.collection.Collection"><code>Collection</code></a> tree into which a distributed module has been imported. E.g. if the above module is distributed as <code>myproject.docs</code>, someone can define a <code>tasks.py</code> that does this:</p>
<pre><code>from invoke import Collection, task
from myproject import docs

@task
def mylocaltask(c):
    # Some local stuff goes here
    pass

# Add 'docs' to our local root namespace, plus our own task
ns = Collection(mylocaltask, docs)
</code></pre>
<p>And then they can add this to the bottom:</p>
<pre><code># Our docs live in 'built_docs', not 'docs/_build'
ns.configure({'sphinx': {'target': &quot;built_docs&quot;}})
</code></pre>
<p>Now we have a <code>docs</code> sub-namespace whose build target defaults to <code>built_docs</code> instead of <code>docs/_build</code>. Runtime users can still override this via flags (e.g. <code>inv docs.build --target='some/other/dir'</code>) just as before.</p>
<p>If you prefer configuration files over in-Python tweaking of your namespace tree, that works just as well; instead of adding the line above to the previous snippet, instead drop this into a file next to <code>tasks.py</code> named <code>invoke.yaml</code>:</p>
<pre><code>sphinx:
    target: built_docs
</code></pre>
<p>For this example, that sort of local-to-project conf file makes the most sense, but don’t forget that the <a href="https://docs.pyinvoke.org/en/latest/concepts/configuration.html#config-hierarchy">config hierarchy</a> offers additional configuration methods which may be suitable depending on your needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fabric-是什么"><a class="header" href="#fabric-是什么">Fabric 是什么？</a></h2>
<p>Python部署工具</p>
<blockquote>
<p>Fabric 是一个 Python (2.5-2.7) 的库和命令行工具，用来提高基于 SSH 的应用部署和系统管理效率。</p>
</blockquote>
<h2 id="hello-fab"><a class="header" href="#hello-fab">Hello, <code>fab</code></a></h2>
<pre><code class="language-python">def hello():
    print(&quot;Hello world!&quot;)
</code></pre>
<p>把上述代码放在你当前的工作目录中一个名为 <code>fabfile.py</code> 的 Python 模块文件中。</p>
<p>然后这个 <code>hello</code> 函数就可以用 <code>fab</code> 工具（随 Fabric 一并安装的命令）来执行了，输出的结果会是这样：</p>
<pre><code class="language-shell">$ fab hello
Hello world!

Done.
</code></pre>
<p>把上述代码放在你当前的工作目录中一个名为 <code>fabfile.py</code> 的 Python 模块文件中。然后这个 <code>hello</code> 函数就可以用 <code>fab</code> 工具（随 Fabric 一并安装的命令）来执行了，输出的结果会是这样：</p>
<p><code>fab</code> 工具所做的只是导入 fabfile 并执行了相应一个或多个的函数，这里并没有任何魔法——任何你能在一个普通 Python 模块中做的事情同样可以在一个 fabfile 中完成。</p>
<h2 id="任务参数"><a class="header" href="#任务参数">任务参数</a></h2>
<p>和你平时的 Python 编程一样，给任务函数传递参数很有必要``。Fabric 支持 Shell 兼容的参数用法： <code>&lt;任务名&gt;:&lt;参数&gt;, &lt;关键字参数名&gt;=&lt;参数值&gt;,...</code> 用起来就是这样，下面我们用一个 say hello 的实例来展开说明一下：</p>
<pre><code>def hello(name=&quot;world&quot;):
    print(&quot;Hello %s!&quot; % name)
</code></pre>
<pre><code class="language-python">$ fab hello:name=Jeff
Hello Jeff!

Done.
</code></pre>
<h2 id="本地命令"><a class="header" href="#本地命令">本地命令</a></h2>
<p>Fabric 的设计目的更是为了使用它自己的 API，包括执行 Shell 命令、传送文件等函数（或操作）接口。</p>
<p>假设我们需要为一个 web 应用创建 fabfile 。具体的情景如下：这个 web 应用的代码使用 git 托管在一台远程服务器 <code>vcshost</code> 上，我们把它的代码库克隆到了本地 <code>localhost</code> 中。</p>
<p>我们希望在我们把修改后的代码 push 回 vcshost 时，自动把新的版本安装到另一台远程服务器 <code>my_server</code> 上</p>
<p>我们将通过自动化本地和远程 git 命令来完成这些工作。</p>
<p>关于 fabfile 文件放置位置的最佳时间是项目的根目录：</p>
<pre><code class="language-python">.
|-- __init__.py
|-- app.wsgi
|-- fabfile.py &lt;-- our fabfile!
|-- manage.py
`-- my_app
    |-- __init__.py
    |-- models.py
    |-- templates
    |   `-- index.html
    |-- tests.py
    |-- urls.py
    `-- views.py
</code></pre>
<p>作为起步，我们希望先执行测试准备好部署后，再提交到 VCS（版本控制系统）：</p>
<pre><code class="language-python">from fabric.api import local

def prepare_deploy():
    local(&quot;./manage.py test my_app&quot;)
    local(&quot;git add -p &amp;&amp; git commit&quot;)
    local(&quot;git push&quot;)
</code></pre>
<p>这段代码很简单，导入一个 Fabric API： <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.local"><code>local</code></a> ，然后用它执行本地 Shell 命令并与之交互，剩下的 Fabric API 也都类似——它们都只是 Python。</p>
<h2 id="用你的方式来组织"><a class="header" href="#用你的方式来组织">用你的方式来组织</a></h2>
<p>比如说，把任务分割成多个子任务：</p>
<pre><code class="language-Python">from fabric.api import local

def test():
    local(&quot;./manage.py test my_app&quot;)

def commit():
    local(&quot;git add -p &amp;&amp; git commit&quot;)

def push():
    local(&quot;git push&quot;)

def prepare_deploy():
    test()
    commit()
    push()
</code></pre>
<p>这个 <code>prepare_deploy</code> 任务仍可以像之前那样调用，但现在只要你愿意，就可以调用更细粒度的子任务。</p>
<h2 id="故障"><a class="header" href="#故障">故障</a></h2>
<p>我们的基本案例已经可以正常工作了，但如果测试失败了会怎样？我们应该抓住机会即使停下任务，并在部署之前修复这些失败的测试。</p>
<p>Fabric 会检查被调用程序的返回值，如果这些程序没有干净地退出，Fabric 会终止操作。下面我们就来看看如果一个测试用例遇到错误时会发生什么：</p>
<pre><code class="language-shell">$ fab prepare_deploy
[localhost] run: ./manage.py test my_app
Creating test database...
Creating tables
Creating indexes
.............E............................
======================================================================
ERROR: testSomething (my_project.my_app.tests.MainTests)
----------------------------------------------------------------------
Traceback (most recent call last):
[...]

----------------------------------------------------------------------
Ran 42 tests in 9.138s

FAILED (errors=1)
Destroying test database...

Fatal error: local() encountered an error (return code 2) while executing './manage.py test my_app'

Aborting.
</code></pre>
<p>但如果我们想更加灵活，给用户另一个选择，该怎么办？一个名为 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/env.html#warn-only">warn_only</a> 的设置（或着说 <strong>环境变量</strong> ，通常缩写为 <strong>env var</strong> ）可以把退出换为警告，以提供更灵活的错误处理。</p>
<p>让我们把这个设置丢到 <code>test</code> 函数中，然后注意这个 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.local"><code>local</code></a> 调用的结果：</p>
<pre><code class="language-python">from __future__ import with_statement
from fabric.api import local, settings, abort
from fabric.contrib.console import confirm

def test():
    with settings(warn_only=True):
        result = local('./manage.py test my_app', capture=True)
    if result.failed and not confirm(&quot;Tests failed. Continue anyway?&quot;):
        abort(&quot;Aborting at user request.&quot;)

[...]
</code></pre>
<pre><code class="language-python">from __future__ import with_statement
from fabric.api import local, settings, abort
from fabric.contrib.console import confirm

def test():
    with settings(warn_only=True):
        result = local('./manage.py test my_app', capture=True)
    if result.failed and not confirm(&quot;Tests failed. Continue anyway?&quot;):
        abort(&quot;Aborting at user request.&quot;)

[...]
</code></pre>
<p>为了引入这个新特性，我们需要添加一些新东西：</p>
<ul>
<li>在 Python 2.5 中，需要从 <code>__future__</code> 中导入 <code>with</code> ；</li>
<li>Fabric <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/contrib/console.html#module-fabric.contrib.console"><code>contrib.console</code></a> 子模块提供了 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/contrib/console.html#fabric.contrib.console.confirm"><code>confirm</code></a> 函数，用于简单的 yes/no 提示。</li>
<li><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/context_managers.html#fabric.context_managers.settings"><code>settings</code></a> 上下文管理器提供了特定代码块特殊设置的功能。</li>
<li><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.local"><code>local</code></a> 这样运行命令的操作会返回一个包含执行结果（ <code>.failed</code> 或 <code>.return_code</code> 属性）的对象。</li>
<li><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/utils.html#fabric.utils.abort"><code>abort</code></a> 函数用于手动停止任务的执行。</li>
</ul>
<h2 id="建立连接"><a class="header" href="#建立连接">建立连接</a></h2>
<p>让我们回到 fabfile 的主旨：定义一个 <code>deploy</code> 任务，让它在一台或多台远程服务器上运行，并保证代码是最新的：</p>
<pre><code class="language-python">def deploy():
    code_dir = '/srv/django/myproject'
    with cd(code_dir):
        run(&quot;git pull&quot;)
        run(&quot;touch app.wsgi&quot;)
</code></pre>
<p>这里再次引入了一些新的概念：</p>
<ul>
<li>Fabric 是 Python——所以我们可以自由地使用变量、字符串等常规的 Python 代码；</li>
<li><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/context_managers.html#fabric.context_managers.cd"><code>cd</code></a> 函数是一个简易的前缀命令，相当于运行 <code>cd /to/some/directory</code> ，和 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/context_managers.html#fabric.context_managers.lcd"><code>lcd</code></a> 函数类似，只不过后者是在本地执行。</li>
<li>~fabric.operations.run和 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.local"><code>local</code></a> 类似，不过是在 <strong>远程</strong> 而非本地执行。</li>
</ul>
<p>我们还需要保证在文件顶部导入了这些新函数：</p>
<pre><code class="language-python">from __future__ import with_statement
from fabric.api import local, settings, abort, run, cd
from fabric.contrib.console import confirm
</code></pre>
<pre><code class="language-python">$ fab deploy
No hosts found. Please specify (single) host string for connection: my_server
[my_server] run: git pull
[my_server] out: Already up-to-date.
[my_server] out:
[my_server] run: touch app.wsgi

Done.
</code></pre>
<p>我们并没有在 fabfile 中指定任何连接信息，所以 Fabric 依旧不知道该在哪里运行这些远程命令。遇到这种情况时，Fabric 会在运行时提示我们。连接的定义使用 SSH 风格的“主机串”（例如： <a href="mailto:user@host">user@host</a>:port ），默认使用你的本地用户名——所以在这个例子中，我们只需要指定主机名 <code>my_server</code> 。</p>
<h3 id="与远程交互"><a class="header" href="#与远程交互">与远程交互</a></h3>
<p>如果你已经得到了代码，说明 <code>git pull</code> 执行非常顺利——但如果这是第一次部署呢？最好也能应付这样的情况，这时应该使用 <code>git clone</code> 来初始化代码库：</p>
<pre><code class="language-python">def deploy():
    code_dir = '/srv/django/myproject'
    with settings(warn_only=True):
        if run(&quot;test -d %s&quot; % code_dir).failed:
            run(&quot;git clone user@vcshost:/path/to/repo/.git %s&quot; % code_dir)
    with cd(code_dir):
        run(&quot;git pull&quot;)
        run(&quot;touch app.wsgi&quot;)
</code></pre>
<p>和上面调用 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.local"><code>local</code></a> 一样， <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.run"><code>run</code></a> 也提供基于 Shell 命令构建干净的 Python 逻辑。</p>
<p><strong>git交互</strong></p>
<p>这里最有趣的部分是 <code>git clone</code> ：因为我们是用 git 的 SSH 方法来访问 git 服务器上的代码库，这意味着我们远程执行的 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.run"><code>run</code></a> 需要自己提供身份验证。</p>
<p>旧版本的 Fabric（和其他类似的高层次 SSH 库）像在监狱里一样运行远程命令，无法提供本地交互。当你迫切需要输入密码或者与远程程序交互时，这就很成问题。</p>
<p>Fabric 1.0 和后续的版本突破了这个限制，并保证你和另一端的会话交互。让我们看看当我们在一台没有 git checkout 的新服务器上运行更新后的 deploy 任务时会发生什么：</p>
<pre><code class="language-shell">$ fab deploy
No hosts found. Please specify (single) host string for connection: my_server
[my_server] run: test -d /srv/django/myproject

Warning: run() encountered an error (return code 1) while executing 'test -d /srv/django/myproject'

[my_server] run: git clone user@vcshost:/path/to/repo/.git /srv/django/myproject
[my_server] out: Cloning into /srv/django/myproject...
[my_server] out: Password: &lt;enter password&gt;
[my_server] out: remote: Counting objects: 6698, done.
[my_server] out: remote: Compressing objects: 100% (2237/2237), done.
[my_server] out: remote: Total 6698 (delta 4633), reused 6414 (delta 4412)
[my_server] out: Receiving objects: 100% (6698/6698), 1.28 MiB, done.
[my_server] out: Resolving deltas: 100% (4633/4633), done.
[my_server] out:
[my_server] run: git pull
[my_server] out: Already up-to-date.
[my_server] out:
[my_server] run: touch app.wsgi

Done.
</code></pre>
<p>注意那个 <code>Password:</code> 提示——那就是我们在 web 服务器上的远程 <code>git</code> 应用在请求 git 密码。我们可以在本地输入密码，然后像往常一样继续克隆。</p>
<p>参见</p>
<p><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/interactivity.html"><em>与远程程序集成</em></a></p>
<h3 id="预定义连接"><a class="header" href="#预定义连接">预定义连接</a></h3>
<p>在运行输入连接信息已经是非常古老的做法了，Fabric 提供了一套在 fabfile 或命令行中指定服务器信息的简单方法</p>
<p>这里我们不展开说明，但是会展示最常用的方法：设置全局主机列表 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/env.html#hosts">env.hosts</a> 。</p>
<p><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/env.html"><em>env</em></a> 是一个全局的类字典对象，是 Fabric 很多设置的基础，也能在 with 表达式中使用（事实上，前面见过的 <code>~fabric.context_managers.settings</code> 就是它的一个简单封装）。因此，我们可以在模块层次上，在 fabfile 的顶部附近修改它，就像这样：</p>
<pre><code class="language-python">from __future__ import with_statement
from fabric.api import *
from fabric.contrib.console import confirm

env.hosts = ['my_server']

def test():
    do_test_stuff()
</code></pre>
<p>当 <code>fab</code> 加载 fabfile 时，将会执行我们对 <code>env</code> 的修改并保存设置的变化。最终结果如上所示：我们的 <code>deploy</code> 任务将在 <code>my_server</code> 上运行。</p>
<p>这就是如何指定 Fabric 一次性控制多台远程服务器的方法： <code>env.hosts</code> 是一个列表， <code>fab</code> 对它迭代，对每个连接运行指定的任务。</p>
<p>参见</p>
<p><a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/env.html"><em>环境字典 env</em></a>, <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/execution.html#host-lists">How host lists are constructed</a></p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>虽然经历了很多，我们的 fabfile 文件仍然相当短。下面是它的完整内容：</p>
<pre><code class="language-python">from __future__ import with_statement
from fabric.api import *
from fabric.contrib.console import confirm

env.hosts = ['my_server']

def test():
    with settings(warn_only=True):
        result = local('./manage.py test my_app', capture=True)
    if result.failed and not confirm(&quot;Tests failed. Continue anyway?&quot;):
        abort(&quot;Aborting at user request.&quot;)

def commit():
    local(&quot;git add -p &amp;&amp; git commit&quot;)

def push():
    local(&quot;git push&quot;)

def prepare_deploy():
    test()
    commit()
    push()

def deploy():
    code_dir = '/srv/django/myproject'
    with settings(warn_only=True):
        if run(&quot;test -d %s&quot; % code_dir).failed:
            run(&quot;git clone user@vcshost:/path/to/repo/.git %s&quot; % code_dir)
    with cd(code_dir):
        run(&quot;git pull&quot;)
        run(&quot;touch app.wsgi&quot;)
</code></pre>
<p>但它已经涉及到了 Fabric 中的很多功能：</p>
<ul>
<li>定义 fabfile 任务，并用 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/usage/fab.html"><em>fab</em></a> 执行；</li>
<li>用 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.local"><code>local</code></a> 调用本地 shell 命令；</li>
<li>通过 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/context_managers.html#fabric.context_managers.settings"><code>settings</code></a> 修改 env 变量；</li>
<li>处理失败命令、提示用户、手动取消任务；</li>
<li>以及定义主机列表、使用 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/api/core/operations.html#fabric.operations.run"><code>run</code></a> 来执行远程命令。</li>
</ul>
<p>还有更多这里没有涉及到的内容，你还可以看看所有“参见”中的链接，以及 <a href="https://fabric-chs.readthedocs.io/zh_CN/chs/index.html"><em>索引页</em></a> 的内容表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-invoke"><a class="header" href="#welcome-to-invoke">Welcome to Invoke!</a></h1>
<p>该网站涵盖了Invoke的项目信息，例如变更日志，贡献指南，开发路线图，新闻/博客等。详细的用法和API文档可以在我们的代码文档网站 docs.pyinvoke.org 上找到。此外，项目维护者在他的网站上保留了路线图。
请参阅下面的高级介绍，或左侧的导航以获取网站的其余内容。</p>
<h2 id="what-is-invoke"><a class="header" href="#what-is-invoke">What is Invoke?</a></h2>
<p>Invoke是一个Python (2.7和3.4) 任务执行工具和库，从各种来源汲取灵感，得出一个强大而干净的功能集。</p>
<ul>
<li>
<p>像Ruby的Rake工具和Invoke自己的前身Fabric 1.x一样，它提供了一个干净的高级API，用于运行shell命令并从tasks.py文件中定义/组织任务函数:</p>
<pre><code class="language-python">from invoke import task

@task
def clean(c, docs=False, bytecode=False, extra=''):
    patterns = ['build']
    if docs:
        patterns.append('docs/_build')
    if bytecode:
        patterns.append('**/*.pyc')
    if extra:
        patterns.append(extra)
    for pattern in patterns:
        c.run(&quot;rm -rf {}&quot;.format(pattern))

@task
def build(c, docs=False):
    c.run(&quot;python setup.py build&quot;)
    if docs:
        c.run(&quot;sphinx-build docs docs/_build&quot;)
</code></pre>
</li>
<li>
<p>从GNU Make开始，它继承了对通用模式的最小样板的强调，并能够在一次调用中运行多个任务:</p>
<pre><code class="language-python">$ invoke clean build
</code></pre>
</li>
<li>
<p>其中Fabric 1.x认为命令行方法的默认使用模式，Invoke (和建立在它上面的工具) 同样在家里嵌入你自己的Python代码或REPL::</p>
<pre><code class="language-python">&gt;&gt;&gt; from invoke import run
&gt;&gt;&gt; cmd = &quot;pip install -r requirements.txt&quot;
&gt;&gt;&gt; result = run(cmd, hide=True, warn=True)
&gt;&gt;&gt; print(result.ok)
True
&gt;&gt;&gt; print(result.stdout.splitlines()[-1])
Successfully installed invocations-0.13.0 pep8-1.5.7 spec-1.3.1
</code></pre>
</li>
<li>
<p>在大多数Unix CLI应用程序的领导下，它提供了一种传统的基于标志的命令行解析风格，从任务签名中导出标志名称和值类型 (当然是可选的!):</p>
<pre><code>$ invoke clean --docs --bytecode build --docs --extra='**/*.pyo'
$ invoke clean -d -b build --docs -e '**/*.pyo'
$ invoke clean -db build -de '**/*.pyo'
</code></pre>
</li>
<li>
<p>像它的许多前辈一样，它也提供了高级功能– namespacing, task aliasing, before/after hooks, parallel execution and more.</p>
</li>
</ul>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>教程/入门文档中解释了许多核心思想和API调用:Getting started</p>
<ul>
<li>定义或运行任务：<a href="https://docs.pyinvoke.org/en/stable/getting-started.html#defining-and-running-task-functions">Defining and running task functions</a></li>
<li>任务参数：<a href="https://docs.pyinvoke.org/en/stable/getting-started.html#task-parameters">Task parameters</a></li>
<li>列出任务：<a href="https://docs.pyinvoke.org/en/stable/getting-started.html#listing-tasks">Listing tasks</a></li>
<li>运行shell任务：<a href="https://docs.pyinvoke.org/en/stable/getting-started.html#running-shell-commands">Running shell commands</a></li>
<li>申明任务：<a href="https://docs.pyinvoke.org/en/stable/getting-started.html#declaring-pre-tasks">Declaring pre-tasks</a></li>
<li>创建名称空间：<a href="https://docs.pyinvoke.org/en/stable/getting-started.html#creating-namespaces">Creating namespaces</a></li>
</ul>
<h2 id="the-invoke-cli-tool"><a class="header" href="#the-invoke-cli-tool">The <code>invoke</code> CLI tool</a></h2>
<p>有关要调用的CLI接口、可用的核心标志和TAB补全：选项的详细信息。</p>
<ul>
<li><code>inv[oke]</code> core usage
<ul>
<li>核心标志：<a href="https://docs.pyinvoke.org/en/stable/invoke.html#core-options-and-flags">Core options and flags</a></li>
<li>Shell tab completion
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/invoke.html#generating-a-completion-script">Generating a completion script</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/invoke.html#sourcing-the-script">Sourcing the script</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/invoke.html#utilizing-tab-completion-itself">Utilizing tab completion itself</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p><strong>深入挖掘</strong></p>
<ul>
<li>Configuration
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#introduction">Introduction</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#the-configuration-hierarchy">The configuration hierarchy</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#default-configuration-values">Default configuration values</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#configuration-files">Configuration files</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#environment-variables">Environment variables</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#collection-based-configuration"><code>Collection</code>-based configuration</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#example-of-real-world-config-use">Example of real-world config use</a></li>
</ul>
</li>
<li>Invoking tasks
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#basic-command-line-layout">Basic command line layout</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#task-command-line-arguments">Task command-line arguments</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#how-tasks-run">How tasks run</a></li>
</ul>
</li>
<li>Using Invoke as a library
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/library.html#reusing-invoke-s-cli-module-as-a-distinct-binary">Reusing Invoke’s CLI module as a distinct binary</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/library.html#customizing-the-configuration-system-s-defaults">Customizing the configuration system’s defaults</a></li>
</ul>
</li>
<li>Loading collections
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html#task-module-discovery">Task module discovery</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html#configuring-the-loading-process">Configuring the loading process</a></li>
</ul>
</li>
<li>Constructing namespaces
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#starting-out">Starting out</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#naming-your-tasks">Naming your tasks</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#nesting-collections">Nesting collections</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#importing-modules-as-collections">Importing modules as collections</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#default-tasks">Default tasks</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#mix-and-match">Mix and match</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#more-shortcuts">More shortcuts</a></li>
</ul>
</li>
<li>Testing Invoke-using codebases
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/testing.html#subclass-modify-invoke-internals">Subclass &amp; modify Invoke ‘internals’</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/testing.html#use-mockcontext">Use <code>MockContext</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/testing.html#expect-results">Expect <code>Results</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/testing.html#avoid-mocking-dependency-code-paths-altogether">Avoid mocking dependency code paths altogether</a></li>
</ul>
</li>
<li>Automatically responding to program output
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/watchers.html#background">Background</a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/concepts/watchers.html#basic-use">Basic use</a></li>
</ul>
</li>
</ul>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<ul>
<li><a href="https://docs.pyinvoke.org/en/stable/api/__init__.html"><code>__init__</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/collection.html"><code>collection</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/config.html"><code>config</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/context.html"><code>context</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/exceptions.html"><code>exceptions</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/executor.html"><code>executor</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/loader.html"><code>loader</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/parser.html"><code>parser</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/program.html"><code>program</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/runners.html"><code>runners</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/tasks.html"><code>tasks</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/terminals.html"><code>terminals</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/util.html"><code>util</code></a></li>
<li><a href="https://docs.pyinvoke.org/en/stable/api/watchers.html"><code>watchers</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defining-and-running-task-functions"><a class="header" href="#defining-and-running-task-functions">Defining and running task functions</a></h2>
<p>The core use case for Invoke is setting up a collection of task functions and executing them. This is pretty easy – all you need is to make a file called <code>tasks.py</code> importing the <a href="https://docs.pyinvoke.org/en/stable/api/tasks.html#invoke.tasks.task"><code>task</code></a> decorator and decorating one or more functions. You will also need to add an arbitrarily-named context argument (convention is to use <code>c</code>, <code>ctx</code> or <code>context</code>) as the first positional arg. Don’t worry about using this context parameter yet.</p>
<p>Let’s start with a dummy Sphinx docs building task:</p>
<p>Invoke的核心用例是设置任务函数的集合并执行它们。这很容易-你所需要的是制作一个名为tasks.py的文件导入任务装饰器并装饰一个或多个函数。您还需要添加一个任意命名的上下文参数 (约定是使用c，ctx或上下文) 作为第一个位置arg。还不用担心使用这个上下文参数。
让我们从一个虚拟狮身人面像(dummy Sphinx )文档构建任务开始:</p>
<pre><code class="language-python">from invoke import task

@task
def build(c):
    print(&quot;Building!&quot;)
</code></pre>
<p>You can then execute that new task by telling Invoke’s command line runner, <code>invoke</code>, that you want it to run:</p>
<p>然后，您可以通过告诉Invoke的命令行运行程序invoke，您希望它运行来执行新任务:</p>
<pre><code>$ invoke build
Building!
</code></pre>
<h2 id="task-parameters"><a class="header" href="#task-parameters">Task parameters</a></h2>
<p>Functions can have arguments, and thus so can tasks. By default, your task functions’ args/kwargs are mapped automatically to both long and short CLI flags, as per <a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#task-arguments">the CLI docs</a>. For example, if we add a <code>clean</code> argument and give it a boolean default, it will show up as a set of toggle flags, <code>--clean</code> and <code>-c</code>:</p>
<p>函数可以有参数，因此任务也可以。默认情况下，根据<a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#task-arguments">the CLI docs</a>.，任务函数的args/kwargs会自动映射到long和short CLI标志。</p>
<p>例如，如果我们添加一个干净的参数并给它一个布尔默认值，它将显示为一组切换标志，-- clean和-c:</p>
<pre><code class="language-python">@task
def build(c, clean=False):
    if clean:
        print(&quot;Cleaning!&quot;)
    print(&quot;Building!&quot;)
</code></pre>
<p>Invocations:</p>
<pre><code class="language-python">$ invoke build -c
$ invoke build --clean
</code></pre>
<p>自然，其他默认参数值将允许给出字符串或整数值。</p>
<p>假设没有默认值的参数采用字符串，也可以作为位置参数给出。</p>
<pre><code>@task
def hi(c, name):
    print(&quot;Hi {}!&quot;.format(name))
</code></pre>
<pre><code class="language-python">$ invoke hi Name
$ invoke hi --name Name
$ invoke hi --name=Name
$ invoke hi -n Name
$ invoke hi -nName
</code></pre>
<h3 id="adding-metadata-via-task"><a class="header" href="#adding-metadata-via-task">Adding metadata via <a href="https://docs.pyinvoke.org/en/stable/api/tasks.html#invoke.tasks.task"><code>@task</code></a></a></h3>
<p><a href="https://docs.pyinvoke.org/en/stable/api/tasks.html#invoke.tasks.task"><code>@task</code></a> can be used without any arguments, as above, but it’s also a convenient vector for additional metadata about the task function it decorates. One common example is describing the task’s arguments, via the <code>help</code> parameter (in addition to optionally giving task-level help via the docstring):</p>
<p><a href="https://docs.pyinvoke.org/en/stable/api/tasks.html#invoke.tasks.task">@ Task</a> 可以在没有任何参数的情况下使用它,但是在任务功能方面具有额外的元数据。</p>
<p>例如帮助：<em>help</em></p>
<pre><code class="language-python">@task(help={'name': &quot;Name of the person to say hi to.&quot;})
def hi(c, name):
    &quot;&quot;&quot;
    Say hi to someone.
    &quot;&quot;&quot;
    print(&quot;Hi {}!&quot;.format(name))
</code></pre>
<pre><code class="language-python">$ invoke --help hi
Usage: inv[oke] [--core-opts] hi [--options] [other tasks here ...]

Docstring:
  Say hi to someone.

Options:
  -n STRING, --name=STRING   Name of the person to say hi to.
</code></pre>
<p>More details on task parameterization and metadata can be found in <a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html">Invoking tasks</a> (for the command-line &amp; parsing side of things) and in the <a href="https://docs.pyinvoke.org/en/stable/api/tasks.html#invoke.tasks.task"><code>task</code></a> API documentation (for the declaration side).</p>
<p>有关任务参数化和元数据的更多详细信息，可以在  <a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html">Invoking tasks</a>   (用于命令行和解析操作) 和 <a href="https://docs.pyinvoke.org/en/stable/api/tasks.html#invoke.tasks.task"><code>task</code></a> API文档 (用于声明侧) 中找到。</p>
<h2 id="listing-tasks"><a class="header" href="#listing-tasks">Listing tasks</a></h2>
<p>列出所有任务</p>
<pre><code>$ invoke --list
Available tasks:

    build
</code></pre>
<p>这也将打印每个任务的docstring的第一行，如果它有一个要查看除了-list之外还有什么可用的，请说invoke-help。</p>
<h2 id="running-shell-commands"><a class="header" href="#running-shell-commands">Running shell commands</a></h2>
<p>Many use cases for Invoke involve running local shell commands, similar to programs like Make or Rake. This is done via the <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.run"><code>run</code></a> function:</p>
<p>Invoke的许多用例都涉及运行本地shell命令，类似于制作或Rake之类的程序。这是通过  <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.run"><code>run</code></a>  函数完成的:</p>
<pre><code class="language-python">from invoke import task

@task
def build(c):
    c.run(&quot;sphinx-build docs docs/_build&quot;)
</code></pre>
<p>你会看到命令的输出在你的终端</p>
<pre><code class="language-python">$ invoke build
Running Sphinx v1.1.3
loading pickled environment... done
...
build succeeded, 2 warnings.
</code></pre>
<p>run具有许多控制其行为的参数，例如为需要它们的复杂程序激活伪终端，抑制错误退出行为，隐藏子进程的输出 (同时仍捕获它以供以后查看) 等等。有关详细信息，请参见其API文档。</p>
<p>运行总是返回一个有用的结果对象，提供对捕获的输出、退出代码和其他信息的访问。</p>
<h3 id="aside-what-exactly-is-this-context-arg-anyway"><a class="header" href="#aside-what-exactly-is-this-context-arg-anyway">Aside: what exactly is this ‘context’ arg anyway?</a></h3>
<blockquote>
<p>上下文到底是什么</p>
</blockquote>
<p>task runners  面临的一个常见问题是传输 “全局” 数据-从  <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html">configuration files</a> or <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#collection-configuration">other configuration vectors</a>,   加载的值，通过CLI标志给出，在 “设置” 任务中生成，等等。</p>
<p>一些库 (如Fabric 1.x) 通过模块级属性实现了这一点，这使得测试变得困难且容易出错，限制了并发性，并增加了实现的复杂性。
Invoke将状态封装在显式上下文对象中，并在执行任务时交给任务。上下文是主要的API端点，提供了展示当前状态 (例  <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.run"><code>Context.run</code></a>)  ） 以及对该状态本身的访问的方法。</p>
<h2 id="declaring-pre-tasks"><a class="header" href="#declaring-pre-tasks">Declaring pre-tasks</a></h2>
<p>可以通过任务装饰器以多种方式配置任务。其中之一是选择您希望在执行任务之前始终运行的一个或多个其他任务，并以名称表示。</p>
<p>让我们用一个新的清理任务来扩展我们的docs builder，该任务在每次构建之前运行 (但是，当然，它仍然可以自己执行):</p>
<pre><code class="language-python">from invoke import task

@task
def clean(c):
    c.run(&quot;rm -rf docs/_build&quot;)

@task(clean)
def build(c):
    c.run(&quot;sphinx-build docs docs/_build&quot;)
</code></pre>
<p>现在，当您调用build时，它将自动首先运行clean。</p>
<p>Note</p>
<p>如果您不喜欢隐式的 “位置参数是预运行任务名称” API，则可以显式给出pre kwarg: @ task(pre =[clean])。</p>
<p>详见： <a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#how-tasks-run">How tasks run</a>.</p>
<h2 id="creating-namespaces"><a class="header" href="#creating-namespaces">Creating namespaces</a></h2>
<p>现在，我们的tasks.py隐含地仅用于文档，但也许我们的项目需要其他非doc的东西，例如打包/部署，测试等。在这一点上，单个平坦的名称空间是不够的，所以Invoke可以让你轻松地构建一个 <a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html">nested namespace</a>.。这里有一个简单的例子。</p>
<p>让我们首先将tasks.py重命名为docs.py; 那里不需要其他更改。然后，我们创建一个新的tasks.py，为了简洁起见，用一个新的、真正的顶层任务部署填充它。</p>
<p>最后，我们可以使用一个新的API成员，即 <a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection"><code>Collection</code></a> 类，将此任务和docs模块绑定到单个显式名称空间中。当Invoke加载您的任务模块时，如果绑定为ns或命名空间的集合对象存在，它将用于根命名空间:</p>
<pre><code class="language-python">from invoke import Collection, task
import docs

@task
def deploy(c):
    c.run(&quot;python setup.py sdist&quot;)
    c.run(&quot;twine upload dist/*&quot;)

namespace = Collection(docs, deploy)
</code></pre>
<pre><code class="language-python">$ invoke --list
Available tasks:

    deploy
    docs.build
    docs.clean
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-options-and-flags"><a class="header" href="#core-options-and-flags">Core options and flags</a></h2>
<p><code>invoke</code>’s usage looks like:</p>
<pre><code class="language-shell">$ inv[oke] [--core-opts] task1 [--task1-opts] ... taskN [--taskN-opts]
</code></pre>
<p>所有核心选项和标志都在下面; 几乎所有这些都必须在任何任务名称之前给出，其中一些 (例如 -- help) 在命令行中的任何位置都要特别查找。(有关解析的详细信息，see <a href="https://docs.pyinvoke.org/en/stable/concepts/invoking-tasks.html#basic-cli-layout">Basic command line layout</a>.。)</p>
<ul>
<li>
<p><code>--complete</code></p>
<p>打印 (行分隔) 有效的tab-completion ，该选项以 “剩余” (即在--之后) 给出。 Used for building <a href="https://docs.pyinvoke.org/en/stable/invoke.html#tab-completion">shell completion scripts</a>.。</p>
<p>例如： when the local tasks tree contains tasks named <code>foo</code> and <code>bar</code>, and when <code>foo</code> takes flags <code>--foo-arg</code> and <code>--foo-arg-2</code>, you might use it like this</p>
<pre><code class="language-shell"></code></pre>
</li>
</ul>
<h1 id="empty-input-just-task-names"><a class="header" href="#empty-input-just-task-names">Empty input: just task names</a></h1>
<p>$ inv --complete -- foo bar </p>
<h1 id="input-not-ending-with-a-dash-task-names-still"><a class="header" href="#input-not-ending-with-a-dash-task-names-still">Input not ending with a dash: task names still</a></h1>
<p>$ inv --complete -- foo --foo-arg foo bar </p>
<h1 id="input-ending-with-a-dash-current-contexts-flag-names"><a class="header" href="#input-ending-with-a-dash-current-contexts-flag-names">Input ending with a dash: current context's flag names</a></h1>
<p>$ inv --complete -- foo - --foo-arg --foo-arg-2</p>
<pre><code>
详见： [`--print-completion-script`](https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-print-completion-script).



- `--hide=STRING`

Set default value of run()’s ‘hide’ kwarg.

- `--no-dedupe`

Disable task deduplication.

- `--print-completion-script=SHELL`

Print a completion script for desired `SHELL` (e.g. `bash`, `zsh`, etc).

​	 	This can be sourced into the current session in order to enjoy [tab-completion for tasks and options](https://docs.pyinvoke.org/en/stable/invoke.html#tab-completion).These scripts are bundled with Invoke’s distributedcodebase, and internally make use of [`--complete`](https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-complete).

- `--prompt-for-sudo-password`

在会话开始时 (在执行任何任务之前) 提示sudo.password配置值。这允许不想在配置系统或其外壳环境中保留敏感材料的用户依赖用户输入，而不会以其他方式中断程序的流程。

- `--write-pyc`

By default, Invoke disables bytecode caching as it can cause hard-to-debug problems with task files and (for the kinds of things Invoke is typically used for) offers no noticeable speed benefit. If you really want your `.pyc` files back, give this option.

默认情况下，Invoke会禁用字节码缓存，因为它会导致任务文件难以调试的问题，并且 (对于Invoke通常用于的类型) 不会提供明显的速度优势。如果你真的想要你的。pyc文件返回，给出此选项。

- `-c STRING, --collection=STRING`

Specify collection name to load.

- `-d,--debug`

Enable debug output.

- `--dry`

Echo命令，而不是实际运行它们; 

* 具体来说，导致任何运行调用 操作，就好像echo选项已打开，打印待运行命令到stdout 

* 跳过实际的子进程调用 (在任何机器开始运行之前返回); 

* 返回具有 'blank' 值的虚拟结果对象 (空stdot/err字符串，0退出代码等)。



- `-D --list-depth=INT`

Limit [`--list`](https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-l) display to the specified number of levels

限制 list显示的任务数

1. e.g. `--list-depth 1` to show only top-level tasks and namespaces
2. If an argument is given to `--list`, then this depth is relative; so `--list build --list-depth 1` shows everything at the top level of the `build` subtree.
3. 默认行为 (如果未给出) 将显示整个任务树的所有级别。

- `-e, --echo`

运行前Echo已执行命令。

- `-f, --config`

1. Specify a [runtime configuration file](https://docs.pyinvoke.org/en/stable/concepts/configuration.html#config-hierarchy) to load.

2. INVOKE_RUNTIME_CONFIG 环境变量如果指定了，则CLI选项获胜

- `-F,--list-format=STRING`

改变 --list 展示格式

**flat**：平面

**json**：json

**nested**：嵌套展示



- `-h STRING, --help=STRING`

- `-l,--list=STRING`

- `-p, --pty`

Use a pty when executing shell commands.

- `-r STRING, --search-root=STRING`

更改用于查找任务模块的根目录。.

- `-T INT, --command-timeout=INT`
* 默认执行任务超时时间
* 同配置 `timeouts.command`

- `-V, --version`

Show version and exit.

- `-w, --warn-only`

Warn, instead of failing, when shell commands fail.



## Shell tab completion

### Generating a completion script

Invoke的理念是实现通用api，然后 “烘烤” 一些在这些api之上构建的常见用例

tab completion 没有什么不同。 通用tab completion (为给定的命令行上下文输出与外壳兼容的完成令牌列表) 由上面描述的 -- complete core CLI选项提供。



但是，您可能不需要自己使用该标志: 我们针对bash和zsh (以及其他) 等最常见的shell分发了一些现成的包装脚本。可以使用 -- print-compliction-script 从Invoke或 [any Invoke-driven command-line tool](https://docs.pyinvoke.org/en/stable/concepts/library.html#reusing-as-a-binary),  自动生成这些脚本; 打印的脚本将包含生成它们的程序的正确二进制名称。



For example, the following command prints (to stdout) a script which works for `zsh`, instructs `zsh` to use it for the `inv` and `invoke` programs, and calls `invoke --complete` at runtime to get dynamic completion information:

例如，以下命令打印 (到stdot) 适用于zsh的脚本，指示zsh将其用于inv并调用程序，并在运行时调用invoke -- complete来获取动态完成信息:

</code></pre>
<p>$ invoke --print-completion-script zsh</p>
<pre><code>


您可能希望将此命令源或将其输出永久存储在某个地方; 在下一节中详细介绍。
同样，[Fabric](http://fabfile.org/) tool  从Invoke继承，并且只有一个二进制名称 (fab); 如果你想在bash中获得结构完成，你会说:

</code></pre>
<p>$ fab --print-completion-script bash</p>
<pre><code>
在本节的其余部分中，我们将在示例中使用inv，但是请记住将其替换为您实际使用的程序，如果它不是调用自己的话!



### Sourcing the script

有几种方法可以利用上述命令的输出，具体取决于您的需求，程序的安装位置以及您的shell:

- 最简单和最少破坏性的方法是源打印完成脚本内联，它不会在磁盘上放置任何东西，只会影响当前的shell会话:

</code></pre>
<p>$ source &lt;(inv --print-completion-script zsh)</p>
<pre><code>
-  如果您在系统的全局Python解释器中提供了该程序 (并且您可以在每个shell会话的启动时运行该程序-Python的速度显然不是其强项)，则可以将该代码片段添加到shell的启动文件中，

such as `~/.zshrc` or `~/.bashrc`.

- 如果该程序在全局范围内可用，但您希望避免在shell启动时运行额外的Python程序，则可以将命令的输出缓存在自己的文件中; 该文件的运行位置完全取决于您以及shell的配置方式。例如，您可以将其作为隐藏文件放入主目录中:

</code></pre>
<p>$ inv --print-completion-script zsh &gt; ~/.invoke-completion.sh
$ source ~/.invoke-completion.sh</p>
<pre><code>


如果您使用的是fish，则必须使用此策略，因为我们的fish completion脚本不适合直接采购。Fish shell用户应将命令的输出定向到〜/.config/fish/completion/目录中的文件。

### Utilizing tab completion itself

您已经确保完成脚本在您的环境中处于活动状态-您获得了什么？

- By default, tabbing after typing `inv` or `invoke` will display task names from your current directory/project’s tasks file.

- 默认情况下，键入inv或invoke后的制表将显示当前目录/项目任务文件中的任务名称。

- 键入破折号 (-) 或双破折号 (-) 后的制表将显示当前上下文的有效选项/标志: 如果尚未键入任务名称，则核心调用选项; 否则为最近键入任务的选项。

&gt; - Tabbing while typing a partial long option will complete matching long options, using your shell’s native substring completion. E.g. if no task names have been typed yet, `--e&lt;tab&gt;` will offer `--echo` as a completion option.

- Hitting tab when the most recent typed/completed token is a flag which takes a value, will ‘fall through’ to your shell’s native filename completion.

&gt; - For example, prior to typing a task name, `--config &lt;tab&gt;` will complete local file paths to assist in filling in a config file.</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>配置搜索，加载，解析和合并的最终结果是一个Config对象，它的行为就像一个 (嵌套的) Python字典。</p>
<p>Invoke在运行时引用此对象 (确定诸如  <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.run"><code>Context.run</code></a> 之类的方法的默认行为)，并将其作为  <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.config"><code>Context.config</code></a>  或上下文本身的速记属性访问方式公开给用户的任务。</p>
<h2 id="the-configuration-hierarchy-1"><a class="header" href="#the-configuration-hierarchy-1">The configuration hierarchy</a></h2>
<p>简而言之，配置值相互覆盖的顺序如下:</p>
<ol>
<li>
<p>内部默认值（<strong>Internal default values</strong>）用于通过配置可控制的行为。 详见： <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#default-values">Default configuration values</a> </p>
</li>
<li>
<p>基于集合的配置：<strong>Collection-driven configurations</strong> defined in tasks modules via <a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection.configure"><code>Collection.configure</code></a>. (See <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#collection-configuration">Collection-based configuration</a> below for details.)</p>
<blockquote>
<p>子集合的配置被合并到顶级集合中，最终结果构成了整个配置设置的基础。</p>
</blockquote>
</li>
<li>
<p>系统层面的配置文件：<strong>System-level configuration file</strong> stored in <code>/etc/</code>, such as <code>/etc/invoke.yaml</code>. (详见： <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#config-files">Configuration files</a> ）</p>
</li>
<li>
<p>用户层面的配置文件：<strong>User-level configuration file</strong>. <code>~/.invoke.yaml</code>.</p>
</li>
<li>
<p>项目层面的配置：<strong>Project-level configuration file</strong> living next to your top level <code>tasks.py</code>. For example, if your run of Invoke loads <code>/home/user/myproject/tasks.py</code> (see our docs on <a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html">the load process</a>), this might be <code>/home/user/myproject/invoke.yaml</code>.</p>
</li>
<li>
<p>环境变量：<strong>Environment variables</strong> found in the invoking shell environment.</p>
<blockquote>
<p>这些不像其他人那样具有强烈的层次性，也不是shell环境命名空间完全由Invoke拥有，所以我们必须依靠稍微冗长的前缀来代替- - 详见 <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#env-vars">Environment variables</a> </p>
</blockquote>
</li>
<li>
<p>命令行指定配置文件：<strong>Runtime configuration file</strong> whose path is given to <a href="https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-f"><code>-f</code></a>, e.g. <code>inv -f /random/path/to/config_file.yaml</code>. This path may also be set via the <code>INVOKE_RUNTIME_CONFIG</code> env var.</p>
</li>
<li>
<p>命令行指定环境变量：<strong>Command-line flags</strong> for certain core settings, such as <a href="https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-e"><code>-e</code></a>.</p>
</li>
<li>
<p>用户代码运行时变更：<strong>Modifications made by user code</strong> at runtime.</p>
</li>
</ol>
<h2 id="default-configuration-values-1"><a class="header" href="#default-configuration-values-1">Default configuration values</a></h2>
<blockquote>
<p>默认配置值</p>
</blockquote>
<p>下面列出了所有配置值和/或section Invoke本身用于控制行为的列表，例如 <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.run"><code>Context.run</code></a>的echo和pty标志，task deduplication等。</p>
<p>这些值的存储位置在 <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.Config"><code>Config</code></a> 类内部，特别是  <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.Config.global_defaults"><code>Config.global_defaults</code></a>;  的返回值; 有关更多详细信息，请参见其API文档。</p>
<p>可以使用嵌套点访问或设置  <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.Config"><code>Config</code></a> and <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context"><code>Context</code></a>  对象</p>
<ul>
<li>
<p>The <code>tasks</code> config tree holds settings relating to task execution.</p>
<blockquote>
<ul>
<li>
<p><code>tasks.dedupe</code> 控制任务重复取消，默认是TRUE、可以通过运行时指定 <a href="https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-no-dedupe"><code>--no-dedupe</code></a>.</p>
</li>
<li>
<p><code>tasks.auto_dash_names</code> 是否自动转换短横杠与下划线. Default: <code>True</code>. See also <a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html#dashes-vs-underscores">Dashes vs underscores</a>.</p>
</li>
<li>
<p><code>tasks.collection_name</code> controls the Python import name sought out by <a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html#collection-discovery">collection discovery</a>, and defaults to <code>&quot;tasks&quot;</code>.</p>
</li>
<li>
<p><code>tasks.executor_class</code> allows users to override the class instantiated and used for task execution.</p>
<p>Must be a fully-qualified dotted path of the form <code>module(.submodule...).class</code>, where all but <code>.class</code> will be handed to <a href="https://docs.python.org/2.7/library/importlib.html#importlib.import_module"><code>importlib.import_module</code></a>, and <code>class</code> is expected to be an attribute on that resulting module object.</p>
<p>Defaults to <code>None</code>, meaning to use the running <a href="https://docs.pyinvoke.org/en/stable/api/program.html#invoke.program.Program"><code>Program</code></a> object’s <code>executor_class</code> attribute.</p>
<p>Warning</p>
<p>Take care if using this setting in tandem with <a href="https://docs.pyinvoke.org/en/stable/concepts/library.html#reusing-as-a-binary">custom program binaries</a>, since custom programs may specify their own default executor class (which your use of this setting will override!) and assume certain behaviors stemming from that.</p>
</li>
<li>
<p><code>tasks.search_root</code> allows overriding the default <a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html#collection-discovery">collection discovery</a> root search location. It defaults to <code>None</code>, which indicates to use the executing process’ current working directory.</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>The <code>run</code> tree controls the behavior of <a href="https://docs.pyinvoke.org/en/stable/api/runners.html#invoke.runners.Runner.run"><code>Runner.run</code></a>. Each member of this tree (such as <code>run.echo</code> or <code>run.pty</code>) maps directly to a <a href="https://docs.pyinvoke.org/en/stable/api/runners.html#invoke.runners.Runner.run"><code>Runner.run</code></a> keyword argument of the same name; see that method’s docstring for details on what these settings do &amp; what their default values are.</p>
</li>
<li>
<p>The <code>runners</code> tree controls <em>which</em> runner classes map to which execution contexts; if you’re using Invoke by itself, this will only tend to have a single member, <code>runners.local</code>. Client libraries may extend it with additional key/value pairs, such as <code>runners.remote</code>.</p>
</li>
<li>
<p>The <code>sudo</code> tree controls the behavior of <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.sudo"><code>Context.sudo</code></a>:</p>
<blockquote>
<ul>
<li>
<p><code>sudo.password</code> controls the autoresponse password submitted to sudo’s password prompt. Default: <code>None</code>.</p>
<p>Warning</p>
<p>While it’s possible to store this setting, like any other, in <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#">configuration files</a> – doing so is inherently insecure. We highly recommend filling this config value in at runtime from a secrets management system of some kind.</p>
</li>
<li>
<p><code>sudo.prompt</code> holds the sudo password prompt text, which is both supplied to <code>sudo -p</code>, and searched for when performing <a href="https://docs.pyinvoke.org/en/stable/concepts/watchers.html">auto-response</a>. Default: <code>[sudo] password:</code>.</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>A top level config setting, <code>debug</code>, controls whether debug-level output is logged; it defaults to <code>False</code>.</p>
<p><code>debug</code> can be toggled via the <a href="https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-d"><code>-d</code></a> CLI flag, which enables debugging after CLI parsing runs. It can also be toggled via the <code>INVOKE_DEBUG</code> environment variable which - unlike regular env vars - is honored from the start of execution and is thus useful for troubleshooting parsing and/or config loading.</p>
</li>
<li>
<p>A small config tree, <code>timeouts</code>, holds various kinds of timeout controls. At present, for Invoke, this only holds a <code>command</code> subkey, which controls subprocess execution timeouts.</p>
<blockquote>
<p>Client code often adds more to this tree, and Invoke itself may add more in the future as well.</p>
</blockquote>
</li>
</ul>
<h2 id="configuration-files-1"><a class="header" href="#configuration-files-1">Configuration files</a></h2>
<h3 id="loading-1"><a class="header" href="#loading-1">Loading</a></h3>
<p>For each configuration file location mentioned in the previous section, we search for files ending in <code>.yaml</code>, <code>.yml</code>, <code>.json</code> or <code>.py</code> (<strong>in that order!</strong>), load the first one we find, and ignore any others that might exist.</p>
<p>For example, if Invoke is run on a system containing both <code>/etc/invoke.yml</code> <em>and</em> <code>/etc/invoke.json</code>, <strong>only the YAML file will be loaded</strong>. This helps keep things simple, both conceptually and in the implementation.</p>
<h3 id="format-1"><a class="header" href="#format-1">Format</a></h3>
<p>Invoke’s configuration allows arbitrary nesting, and thus so do our config file formats. All three of the below examples result in a configuration equivalent to <code>{'debug': True, 'run': {'echo': True}}</code>:</p>
<ul>
<li>
<p><strong>YAML</strong></p>
<pre><code>debug: true
run:
    echo: true
</code></pre>
</li>
<li>
<p><strong>JSON</strong></p>
<pre><code>{
    &quot;debug&quot;: true,
    &quot;run&quot;: {
        &quot;echo&quot;: true
    }
}
</code></pre>
</li>
<li>
<p><strong>Python</strong>:</p>
<pre><code>debug = True
run = {
    &quot;echo&quot;: True
}
</code></pre>
</li>
</ul>
<p>For further details, see these languages’ own documentation.</p>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment variables</a></h2>
<p>Environment variables are a bit different from other configuration-setting methods, since they don’t provide a clean way to nest configuration keys, and are also implicitly shared amongst the entire system’s installed application base.</p>
<p>In addition, due to implementation concerns, env vars must be pre-determined by the levels below them in the config hierarchy (in other words - env vars may only be used to override existing config values). If you need Invoke to understand a <code>FOOBAR</code> environment variable, you must first declare a <code>foobar</code> setting in a configuration file or in your task collections.</p>
<h3 id="basic-rules-1"><a class="header" href="#basic-rules-1">Basic rules</a></h3>
<p>To mitigate the shell namespace problem, we simply prefix all our env vars with <code>INVOKE_</code>.</p>
<p>Nesting is performed via underscore separation, so a setting that looks like e.g. <code>{'run': {'echo': True}}</code> at the Python level becomes <code>INVOKE_RUN_ECHO=1</code> in a typical shell. See <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#env-var-nesting">Nesting vs underscored names</a> below for more on this.</p>
<h3 id="type-casting-1"><a class="header" href="#type-casting-1">Type casting</a></h3>
<p>Since env vars can only be used to override existing settings, the previous value of a given setting is used as a guide in casting the strings we get back from the shell:</p>
<ul>
<li>
<p>If the current value is a string or Unicode object, it is replaced with the value from the environment, with no casting whatsoever;</p>
<blockquote>
<ul>
<li>Depending on interpreter and environment, this means that a setting defaulting to a non-Unicode string type (eg a <code>str</code> on Python 2) may end up replaced with a Unicode string, or vice versa. This is intentional as it prevents users from accidentally limiting themselves to non-Unicode strings.</li>
</ul>
</blockquote>
</li>
<li>
<p>If the current value is <code>None</code>, it too is replaced with the string from the environment;</p>
</li>
<li>
<p>Booleans are set as follows: <code>0</code> and the empty value/string (e.g. <code>SETTING=</code>, or <code>unset SETTING</code>, or etc) evaluate to <code>False</code>, and any other value evaluates to <code>True</code>.</p>
</li>
<li>
<p>Lists and tuples are currently unsupported and will raise an exception;</p>
<blockquote>
<ul>
<li>In the future we may implement convenience transformations, such as splitting on commas to form a list; however since users can always perform such operations themselves, it may not be a high priority.</li>
</ul>
</blockquote>
</li>
<li>
<p>All other types - integers, longs, floats, etc - are simply used as constructors for the incoming value.</p>
<blockquote>
<ul>
<li>For example, a <code>foobar</code> setting whose default value is the integer <code>1</code> will run all env var inputs through <a href="https://docs.python.org/2.7/library/functions.html#int"><code>int</code></a>, and thus <code>FOOBAR=5</code> will result in the Python value <code>5</code>, not <code>&quot;5&quot;</code>.</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="nesting-vs-underscored-names-1"><a class="header" href="#nesting-vs-underscored-names-1">Nesting vs underscored names</a></h3>
<p>Since environment variable keys are single strings, we must use some form of string parsing to allow access to nested configuration settings. As mentioned above, in basic use cases this just means using an underscore character: <code>{'run': {'echo': True}}</code> becomes <code>INVOKE_RUN_ECHO=1</code>.</p>
<p>However, ambiguity is introduced when the settings names themselves contain underscores: is <code>INVOKE_FOO_BAR=baz</code> equivalent to <code>{'foo': {'bar': 'baz'}}</code>, or to <code>{'foo_bar': 'baz'}</code>? Thankfully, because env vars can only be used to modify settings declared at the Python level or in config files, we look at the current state of the config to determine the answer.</p>
<p>There is still a corner case where <em>both</em> possible interpretations exist as valid config paths (e.g. <code>{'foo': {'bar': 'default'}, 'foo_bar': 'otherdefault'}</code>). In this situation, we honor the <a href="http://zen-of-python.info/in-the-face-of-ambiguity-refuse-the-temptation-to-guess.html#12">Zen of Python</a> and refuse to guess; an error is raised instead, counseling users to modify their configuration layout or avoid using env vars for the setting in question.</p>
<h2 id="collection-based-configuration-1"><a class="header" href="#collection-based-configuration-1"><a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection"><code>Collection</code></a>-based configuration</a></h2>
<p><a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection"><code>Collection</code></a> objects may contain a config mapping, set via <a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection.configure"><code>Collection.configure</code></a>, and (as per <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#config-hierarchy">the hierarchy</a>) this typically forms the lowest level of configuration in the system.</p>
<p>When collections are <a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html">nested</a>, configuration is merged ‘downwards’ by default: when conflicts arise, outer namespaces closer to the root will win, versus inner ones closer to the task being invoked.</p>
<p>Note</p>
<p>‘Inner’ tasks here are specifically those on the path from the root to the one housing the invoked task. ‘Sibling’ subcollections are ignored.</p>
<p>A quick example of what this means:</p>
<pre><code>from invoke import Collection, task

# This task &amp; collection could just as easily come from
# another module somewhere.
@task
def mytask(c):
    print(c['conflicted'])
inner = Collection('inner', mytask)
inner.configure({'conflicted': 'default value'})

# Our project's root namespace.
ns = Collection(inner)
ns.configure({'conflicted': 'override value'})
</code></pre>
<p>The result of calling <code>inner.mytask</code>:</p>
<pre><code>$ inv inner.mytask
override value
</code></pre>
<h2 id="example-of-real-world-config-use-1"><a class="header" href="#example-of-real-world-config-use-1">Example of real-world config use</a></h2>
<p>The previous sections had small examples within them; this section provides a more realistic-looking set of examples showing how the config system works.</p>
<h3 id="setup-1"><a class="header" href="#setup-1">Setup</a></h3>
<p>We’ll start out with semi-realistic tasks that hardcode their values, and build up to using the various configuration mechanisms. A small module for building <a href="http://sphinx-doc.org/">Sphinx</a> docs might begin like this:</p>
<pre><code>from invoke import task

@task
def clean(c):
    c.run(&quot;rm -rf docs/_build&quot;)

@task
def build(c):
    c.run(&quot;sphinx-build docs docs/_build&quot;)
</code></pre>
<p>Then maybe you refactor the build target:</p>
<pre><code>target = &quot;docs/_build&quot;

@task
def clean(c):
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c):
    c.run(&quot;sphinx-build docs {}&quot;.format(target))
</code></pre>
<p>We can also allow runtime parameterization:</p>
<pre><code>default_target = &quot;docs/_build&quot;

@task
def clean(c, target=default_target):
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c, target=default_target):
    c.run(&quot;sphinx-build docs {}&quot;.format(target))
</code></pre>
<p>This task module works for a single set of users, but what if we want to allow reuse? Somebody may want to use this module with a different default target. Using the configuration data (made available via the context arg) to configure these settings is usually the better solution [<a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#id3">1]</a>.</p>
<h3 id="configuring-via-task-collection-1"><a class="header" href="#configuring-via-task-collection-1">Configuring via task collection</a></h3>
<p>The configuration <a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection.configure"><code>setting</code></a> and <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.config"><code>getting</code></a> APIs enable moving otherwise ‘hardcoded’ default values into a config structure which downstream users are free to redefine. Let’s apply this to our example. First we add an explicit namespace object:</p>
<pre><code>from invoke import Collection, task

default_target = &quot;docs/_build&quot;

@task
def clean(c, target=default_target):
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c, target=default_target):
    c.run(&quot;sphinx-build docs {}&quot;.format(target))

ns = Collection(clean, build)
</code></pre>
<p>Then we can move the default build target value into the collection’s default configuration, and refer to it via the context. At this point we also change our kwarg default value to be <code>None</code> so we can determine whether or not a runtime value was given. The result:</p>
<pre><code>@task
def clean(c, target=None):
    if target is None:
        target = c.sphinx.target
    c.run(&quot;rm -rf {}&quot;.format(target))

@task
def build(c, target=None):
    if target is None:
        target = c.sphinx.target
    c.run(&quot;sphinx-build docs {}&quot;.format(target))

ns = Collection(clean, build)
ns.configure({'sphinx': {'target': &quot;docs/_build&quot;}})
</code></pre>
<p>The result isn’t significantly more complex than what we began with, and as we’ll see next, it’s now trivial for users to override your defaults in various ways.</p>
<h3 id="configuration-overriding-1"><a class="header" href="#configuration-overriding-1">Configuration overriding</a></h3>
<p>The lowest-level override is, of course, just modifying the local <a href="https://docs.pyinvoke.org/en/stable/api/collection.html#invoke.collection.Collection"><code>Collection</code></a> tree into which a distributed module has been imported. E.g. if the above module is distributed as <code>myproject.docs</code>, someone can define a <code>tasks.py</code> that does this:</p>
<pre><code>from invoke import Collection, task
from myproject import docs

@task
def mylocaltask(c):
    # Some local stuff goes here
    pass

# Add 'docs' to our local root namespace, plus our own task
ns = Collection(mylocaltask, docs)
</code></pre>
<p>And then they can add this to the bottom:</p>
<pre><code># Our docs live in 'built_docs', not 'docs/_build'
ns.configure({'sphinx': {'target': &quot;built_docs&quot;}})
</code></pre>
<p>Now we have a <code>docs</code> sub-namespace whose build target defaults to <code>built_docs</code> instead of <code>docs/_build</code>. Runtime users can still override this via flags (e.g. <code>inv docs.build --target='some/other/dir'</code>) just as before.</p>
<p>If you prefer configuration files over in-Python tweaking of your namespace tree, that works just as well; instead of adding the line above to the previous snippet, instead drop this into a file next to <code>tasks.py</code> named <code>invoke.yaml</code>:</p>
<pre><code>sphinx:
    target: built_docs
</code></pre>
<p>For this example, that sort of local-to-project conf file makes the most sense, but don’t forget that the <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#config-hierarchy">config hierarchy</a> offers additional configuration methods which may be suitable depending on your needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-collections"><a class="header" href="#loading-collections">Loading collections</a></h1>
<p>The core of Invoke’s execution model involves one or more Collection objects. While these may be created programmatically, in typical use Invoke will create them for you from Python modules it finds or is told to use.</p>
<p>Invoke的执行模型的核心涉及一个或多个集合对象。虽然这些可以以编程方式创建，但在典型的使用中，Invoke会从它找到或被告知要使用的Python模块为您创建它们。</p>
<h2 id="task-module-discovery"><a class="header" href="#task-module-discovery">Task module discovery</a></h2>
<p>With no other configuration, simply calling <code>invoke</code> will look for a single Python module or package named <code>tasks</code>, and will treat it as the root namespace. </p>
<p>在没有其他配置的情况下，简单地调用invoke将查找名为tasks的单个Python模块或包，并将其视为根命名空间。</p>
<p><code>tasks</code> (or any other name given via <a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html#configuring-loading">loading configuration options</a>) is searched for in the following ways:</p>
<p>通过以下方式搜索 “任务” (或通过 <a href="https://docs.pyinvoke.org/en/stable/concepts/loading.html#configuring-loading">loading configuration options</a> 给出的任何其他名称):</p>
<ul>
<li>
<p>首先，如果Python的sys.path上已经存在该名称的有效任务模块，则不再进行搜索-选择该模块。</p>
</li>
<li>
<p>Failing that, search towards the root of the local filesystem, starting with the user’s current working directory (<a href="http://docs.python.org/release/2.7/library/os.html#os.getcwd">os.getcwd</a>) and try importing again with each directory temporarily added to <code>sys.path</code>.</p>
<blockquote>
<ul>
<li>由于Python的导入机制是如何工作的，这种方法总是倾向于包目录 (tasks/包含 <strong>init</strong>.py) 而不是位于同一位置的模块文件 (tasks.py)。</li>
<li>If a candidate is found and successfully imported, its parent directory will <strong>stay</strong> on <code>sys.path</code> during the rest of the Python session – this allows task code to make convenient assumptions concerning sibling modules’ importability.</li>
</ul>
</blockquote>
</li>
</ul>
<p>对候选模块/包进行了内省，以确保它们实际上可以用作有效的任务集合。任何失败的都将被丢弃，导入它们的sys.path munging将被还原，搜索将继续。</p>
<h2 id="configuring-the-loading-process"><a class="header" href="#configuring-the-loading-process">Configuring the loading process</a></h2>
<blockquote>
<p>配置加载过程</p>
</blockquote>
<p>您可以配置上述行为，请求调用更改搜索的集合名称和/或文件系统级加载开始查找的路径。</p>
<p>例如，您可能已经有一个无法轻松重命名的项目级 <code>tasks.py</code> ; 或者您可能希望托管存储在项目根目录之外的多个任务集合，并使它们之间的切换变得容易; 或者任何原因。</p>
<p>Both the sought collection name and the search root can be specified via <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#config-files">configuration file options</a> or as <a href="https://docs.pyinvoke.org/en/stable/invoke.html">runtime CLI flags</a>:</p>
<ul>
<li><strong>Change the collection name</strong>: Set the <code>tasks.collection_name</code> configuration option, or use <a href="https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-c"><code>--collection</code></a>. It should be a Python module name and not a file name (so <code>mytasks</code>, not <code>mytasks.py</code> or <code>mytasks/</code>.)</li>
<li><strong>Change the root search path</strong>: Configure <code>tasks.search_root</code> or use <a href="https://docs.pyinvoke.org/en/stable/invoke.html#cmdoption-r"><code>--search-root</code></a>. This value may be any valid directory path.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-invoke-as-a-library"><a class="header" href="#using-invoke-as-a-library">Using Invoke as a library</a></h1>
<p>虽然我们的大多数文档都涉及用户/CLI面对任务管理和命令执行的用例，但Invoke的设计目的是让高级用户可以独立使用其组成部分-开箱即用或最少的额外工作。CLI解析，子流程命令执行，任务组织等都被写成广泛分离的关注点。
本文档概述了已知可行的用例 (因为像Fabric这样的下游工具已经在利用它们)。</p>
<h2 id="reusing-invokes-cli-module-as-a-distinct-binary"><a class="header" href="#reusing-invokes-cli-module-as-a-distinct-binary">Reusing Invoke’s CLI module as a distinct binary</a></h2>
<p>一个主要的用例是在引擎盖下使用Invoke分发自己的程序，绑定到不同的二进制名称，并且通常将特定的任务命名空间设置为默认值。(这与标准库中的argparse类似的东西有点接近。)在某些情况下，还需要移除、替换和/或添加核心CLI标志。</p>
<h3 id="getting-set-up"><a class="header" href="#getting-set-up">Getting set up</a></h3>
<p>假设您要分发一个名为tester的测试运行器，提供两个子命令，即单元和集成，以便用户可以pip安装tester并可以访问tester unit，tester integration或tester integration-fail-fast之类的命令。
首先，与提供CLI “二进制” 的任何不同的Python包一样，您将通知您的setup.py您的入口点:</p>
<pre><code>setup(
    name='tester',
    version='0.1.0',
    packages=['tester'],
    install_requires=['invoke'],
    entry_points={
        'console_scripts': ['tester = tester.main:program.run']
    }
)
</code></pre>
<p>This is just an example snippet and is not a fully valid <code>setup.py</code>; if you don’t know how Python packaging works, a good starting place is <a href="https://python-packaging-user-guide.readthedocs.io/">the Python Packaging User’s Guide</a>.</p>
<p>这里没有什么是特定的Invoke-这是告诉Python安装一个测试器脚本的标准方法，该脚本执行在模块tester.main中定义的程序对象的run方法。</p>
<h3 id="creating-a-program"><a class="header" href="#creating-a-program">Creating a <code>Program</code></a></h3>
<p>In our <code>tester/main.py</code>, we start out importing Invoke’s public CLI functionality:</p>
<pre><code>from invoke import Program
</code></pre>
<p>然后我们定义我们在setup.py中引用的程序对象，这是一个简单的程序来完成繁重的工作，为初学者提供我们的版本号:</p>
<pre><code>program = Program(version='0.1.0')
</code></pre>
<p>At this point, installing <code>tester</code> would give you the same functionality as Invoke’s <a href="https://docs.pyinvoke.org/en/stable/invoke.html">built-in CLI tool</a>, except named <code>tester</code> and exposing its own version number:</p>
<pre><code class="language-shell">$ tester --version
Tester 0.1.0
$ tester --help
Usage: tester [--core-opts] task1 [--task1-opts] ... taskN [--taskN-opts]

Core options:
    ... core Invoke options here ...

$ tester --list
Can't find any collection named 'tasks'!
</code></pre>
<p>This doesn’t do us much good yet - there aren’t any subcommands (and our users don’t care about arbitrary ‘tasks’, so Invoke’s own default <code>--help</code> and <code>--list</code> output isn’t a good fit).</p>
<h3 id="specifying-subcommands"><a class="header" href="#specifying-subcommands">Specifying subcommands</a></h3>
<p>For <code>tester</code> to expose <code>unit</code> and <code>integration</code> subcommands, we need to define them, in a regular Invoke tasks module or <a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html">namespace</a>. For our example, we’ll just create <code>tester/tasks.py</code> (but as you’ll see in a moment, this too is arbitrary and can be whatever you like):</p>
<pre><code>from invoke import task

@task
def unit(c):
    print(&quot;Running unit tests!&quot;)

@task
def integration(c):
    print(&quot;Running integration tests!&quot;)
</code></pre>
<p>As described in <a href="https://docs.pyinvoke.org/en/stable/concepts/namespaces.html">Constructing namespaces</a>, you can arrange this module however you want - the above snippet uses an implicit namespace for brevity’s sake.</p>
<p>Note</p>
<p>It’s important to realize that there’s nothing special about these “subcommands” - you could run them just as easily with vanilla Invoke, e.g. via <code>invoke --collection=tester.tasks --list</code>.</p>
<p>Now the useful part: telling our custom <a href="https://docs.pyinvoke.org/en/stable/api/program.html#invoke.program.Program"><code>Program</code></a> that this namespace of tasks should be used as the subcommands for <code>tester</code>, via the <code>namespace</code> kwarg:</p>
<pre><code class="language-python">from invoke import Collection, Program
from tester import tasks

program = Program(namespace=Collection.from_module(tasks), version='0.1.0')
</code></pre>
<p>The result?</p>
<pre><code>$ tester --version
Tester 0.1.0
$ tester --help
Usage: tester [--core-opts] &lt;subcommand&gt; [--subcommand-opts] ...

Core options:
  ... core options here, minus task-related ones ...

Subcommands:
  unit
  integration

$ tester --list
No idea what '--list' is!
$ tester unit
Running unit tests!
</code></pre>
<p>Notice how the ‘usage’ line changed (to specify ‘subcommands’ instead of ‘tasks’); the list of specific subcommands is now printed as part of <code>--help</code>; and <code>--list</code> has been removed from the options.</p>
<p>You can enable <a href="https://docs.pyinvoke.org/en/stable/invoke.html#tab-completion">tab-completion</a> for your distinct binary and subcommands.</p>
<h3 id="modifying-core-parser-arguments"><a class="header" href="#modifying-core-parser-arguments">Modifying core parser arguments</a></h3>
<p>A common need for this use case is tweaking the core parser arguments. <a href="https://docs.pyinvoke.org/en/stable/api/program.html#invoke.program.Program"><code>Program</code></a> makes it easy: default core <a href="https://docs.pyinvoke.org/en/stable/api/parser.html#invoke.parser.argument.Argument"><code>Arguments</code></a> are returned by <a href="https://docs.pyinvoke.org/en/stable/api/program.html#invoke.program.Program.core_args"><code>Program.core_args</code></a>. Extend this method’s return value with <code>super</code> and you’re done:</p>
<pre><code class="language-python"># Presumably, this is your setup.py-designated CLI module...

from invoke import Program, Argument

class MyProgram(Program):
    def core_args(self):
        core_args = super(MyProgram, self).core_args()
        extra_args = [
            Argument(names=('foo', 'f'), help=&quot;Foo the bars&quot;),
            # ...
        ]
        return core_args + extra_args

program = MyProgram()
</code></pre>
<p>Warning</p>
<p>我们不建议省略任何现有的核心参数; 许多基本功能依赖于它们的存在，即使保留默认值也是如此。</p>
<h2 id="customizing-the-configuration-systems-defaults"><a class="header" href="#customizing-the-configuration-systems-defaults">Customizing the configuration system’s defaults</a></h2>
<p>Besides the CLI-oriented content of the previous section, another area of functionality that frequently needs updating when redistributing an Invoke codebase (CLI or no CLI) is configuration. There are typically two concerns here:</p>
<ul>
<li>Configuration filenames and the env var prefix - crucial if you ever expect your users to use the configuration system;</li>
<li>Default configuration values - less critical (most defaults aren’t labeled with anything Invoke-specific) but still sometimes desirable.</li>
</ul>
<p>Note</p>
<p>Both of these involve subclassing <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.Config"><code>Config</code></a> (and, if using the CLI machinery, informing your <a href="https://docs.pyinvoke.org/en/stable/api/program.html#invoke.program.Program"><code>Program</code></a> to use that subclass instead of the default one.)</p>
<h3 id="changing-filenames-andor-env-var-prefix"><a class="header" href="#changing-filenames-andor-env-var-prefix">Changing filenames and/or env var prefix</a></h3>
<p>By default, Invoke’s config system looks for files like <code>/etc/invoke.yaml</code>, <code>~/.invoke.json</code>, etc. If you’re distributing client code named something else, like the <code>Tester</code> example earlier, you might instead want the config system to load <code>/etc/tester.json</code> or <code>$CWD/tester.py</code>.</p>
<p>Similarly, the environment variable config level looks for env vars like <code>INVOKE_RUN_ECHO</code>; you might prefer <code>TESTER_RUN_ECHO</code>.</p>
<p>There are a few <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.Config"><code>Config</code></a> attributes controlling these values:</p>
<ul>
<li><code>prefix</code>: A generic, catchall prefix used directly as the file prefix, and used via all-caps as the env var prefix;</li>
<li><code>file_prefix</code>: For overriding just the filename prefix - otherwise, it defaults to the value of <code>prefix</code>;</li>
<li><code>env_prefix</code>: For overriding just the env var prefix - as you might have guessed, it too defaults to the value of <code>prefix</code>.</li>
</ul>
<p>Continuing our ‘Tester’ example, you’d do something like this:</p>
<pre><code>from invoke import Config

class TesterConfig(Config):
    prefix = 'tester'
</code></pre>
<p>Or, to seek <code>tester.yaml</code> as before, but <code>TEST_RUN_ECHO</code> instead of <code>TESTER_RUN_ECHO</code>:</p>
<pre><code>class TesterConfig(Config):
    prefix = 'tester'
    env_prefix = 'TEST'
</code></pre>
<h3 id="modifying-default-config-values"><a class="header" href="#modifying-default-config-values">Modifying default config values</a></h3>
<p>Default config values are simple - they’re just the return value of the staticmethod <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.Config.global_defaults"><code>Config.global_defaults</code></a>, so override that and return whatever you like - ideally something based on the superclass’ values, as many defaults are assumed to exist by the rest of the system. (The helper function <a href="https://docs.pyinvoke.org/en/stable/api/config.html#invoke.config.merge_dicts"><code>invoke.config.merge_dicts</code></a> can be useful here.)</p>
<p>For example, say you want Tester to always echo shell commands by default when your codebase calls <a href="https://docs.pyinvoke.org/en/stable/api/context.html#invoke.context.Context.run"><code>Context.run</code></a>:</p>
<pre><code>from invoke import Program
from invoke.config import Config, merge_dicts

class TesterConfig(Config):
    @staticmethod
    def global_defaults():
        their_defaults = Config.global_defaults()
        my_defaults = {
            'run': {
                'echo': True,
            },
        }
        return merge_dicts(their_defaults, my_defaults)

program = Program(config_class=TesterConfig, version='0.1.0')
</code></pre>
<p>For reference, Invoke’s own base defaults (the…default defaults, you could say) are documented at <a href="https://docs.pyinvoke.org/en/stable/concepts/configuration.html#default-values">Default configuration values</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
